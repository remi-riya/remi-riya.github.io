---
title: 生成函数及其他
tags:
  - 算法
categories:
  - ACM
katex: true
abbrlink: 51455
date: 2024-02-04 10:43:40
---

（超长文章警告）

事情的起因是写题时碰到了第二类斯特林数，然后百度学习的过程中就看到了斯特林数的两种求法，递推法与生成函数法。由于递推法复杂度较高用的较少，所以只能无奈学习生成函数。然后，就打开了新世界的大门……于是又被迫学习了一堆前置算法，由于内容较杂，于是采用边学边写文章总结的方法。所以这是一篇类似于学习笔记的文章，当然我也会尽力地总结，并尝试以自认为更通俗易懂的方法解释学到的新算法。由于是边学边写，可能思路会比较混乱，以后可能会抽时间在总结一次（这么说大概率是没时间了_(:з)∠)_）。

## 生成函数的简单介绍

那么首先，先简单的说明一下生成函数是什么。维基百科上是这样说的

> 在数学中，某个序列$(a_n)_{n \in N}$的母函数（又称生成函数，英语：Generating function）是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。

序列$(a_n)_{n \in N}$的生成函数就是$G(X) = \sum\limits_{n=0}\limits^{\infty}{a_n x^n}$。 举个简单的例子，序列$(1,1,\dots,1)$的生成函数就是$G(x) = \sum\limits_{n = 0}\limits^{\infty}{x^n}$，也就是把序列$(a_n)_{n \in N}$的每一项作为对应的$x^n$的系数，因为在这里$x$的值没有意义，所以叫做形式幂级数。再引用维基百科上引用的一句话来说明

><p align="center">**母函数就是一列用来展示一串数字的挂衣架。**<p>
><p align="right">——赫伯特·维尔夫<p>

至于生成函数有什么用，这个~~等我学完~~等下再说。首先，如果想在程序里使用生成函数，需要一些前置知识。

## 多项式相关及快速傅里叶变换

生成函数是形式幂级数，想要使用，就要先对计算机处理多项式的方法有一定的理解。在这里，可以用高斯消元的代码来辅助理解一下。

```c++
template <typename T, std::size_t N>
int solve(T (&a)[N][N], T (&b)[N], int n)
{
    int r = 1;
    for (int i = 1; i <= n; ++i) {
        int max = 0;
        for (int j = r; j <= n; ++j) {
            if (std::fabs(a[j][i]) > std::fabs(a[max][i]))
                max = j;
        }
        if (std::fabs(a[max][i]) < 1e-9)
            continue;
        for (int k = 1; k <= n; ++k)
            std::swap(a[r][k], a[max][k]);
        std::swap(b[r], b[max]);
        for (int j = 1; j <= n; ++j) {
            if (j == r)
                continue;
            auto rate = a[j][i] / a[r][i];
            for (int k = 1; k <= n; ++k)
                a[j][k] -= a[r][k] * rate;
            b[j] -= b[r] * rate;
        }
        r++;
    }
    if (--r < n) {
        for (int i = r + 1; i <= n; ++i)
            if (std::fabs(b[i]) > 1e-9)
                return -1; // 无解
        return 0; // 无穷解
    }
    return 1314; // 唯一解
}
```

至于为什么突然提到高斯消元，是因为在没学之前我一直觉得高斯消元会很复杂，毕竟计算机解方程这种事总觉得会很麻烦，我人脑算都感觉要昏迷了＞﹏＜。但是实际写了之后又发现其实代码并没有想的那么复杂，大为震撼。高斯消元也可以算是所学的第一个解决纯数学问题的代码。

那么从高斯消元的代码中我们也可以对于计算机对多项式的存储与处理有个大概的概念。计算机处理多项式一般是用数组存储系数，而未知数则反映在下标中。
了解了这一点，就可以准备开始快速傅里叶变换了。

---

### 多项式

首先为了理解快速傅里叶变换的作用，我们要了解一下多项式的两种表示方式——系数法和点值法。
在学二次函数的时候我们就学过，平面上任意三个不相同的点可以确定唯一的一条二次曲线，这个结论其实是可以推广的，也就是说，对于任意一个多项式
$$F(x)=\sum\limits_{i=0}\limits^{n-1}{a_i x^i}$$
我们都可以用$n$个不同的点$(x_0, y_0), (x_1, y_1), \ldots, (x_{n-1}, y_{n-1})$来表示，其中$y_i = F(x_i)$。
这个结论的证明也比较简单，我们只要把这$n$个点带入多项式，就能得到一个线性方程组
$$
\left\{
    \begin{array}{c}
        a_0+a_1x_0+a_2x_0^2 + \cdots + a_{n-1}x_0^{n-1}=y_0 \\
        a_0+a_1x_1+a_2x_1^2 + \cdots + a_{n-1}x_1^{n-1}=y_1 \\
        a_0+a_1x_2+a_2x_2^2 + \cdots + a_{n-1}x_2^{n-1}=y_2 \\
        \vdots \\
        a_0+a_1x_{n-1}+a_2x_{n-1}^2 + \cdots + a_{n-1}x_{n-1}^{n-1}=y_{n-1} \\
    \end{array}
\right.
$$
将系数单独取出构成行列式
$$
\begin{vmatrix}
    1 & x_0 & x_0^2 & \cdots & x_0^{n-1} \\
    1 & x_1 & x_1^2 & \cdots & x_1^{n-1} \\
    1 & x_2 & x_2^2 & \cdots & x_2^{n-1} \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\
    1 & x_{n-1} & x_{n-1}^2 & \cdots & x_{n-1}^{n-1}
\end{vmatrix}
$$
这是一个范德蒙德行列式，当$x_i$互不相等时，行列式不为0，线性方程组有唯一解，于是可以得到唯一的多项式。

说了这么多，点值表示法到底有什么作用呢？
让我们来思考这样一个问题，计算两个多项式$F(x)$，$G(x)$相乘要多久？在系数表示法下，答案显然是$O(n^2)$，我们需要把第一个多项式的每一项与第二个多项式的每一项相乘。但是如果是点值表示法呢？由于$n$个点可以对应唯一的一个$n$次多项式，如果我们在两个多项式中都选取$2n$个$x$，转换为点值表示法（$2n$个点也是可以得出$n$次的多项式的，只是大于$n$次的项系数为0而已），那么，我们只要计算$F(x) \cdot G(x)$，就可以得到对应的位于相乘结果的多项式上的点，只要有$2n$个点，就可以对应一个$2n$次的多项式，也就是结果，复杂度为$O(n)$！

在点值表示法下，原本$O(n^2)$的多项式乘法只需要$O(n)$就能完成，这大大优化了速度。但是，我们平常使用多项式时都是系数表示法，点值表示法除了能够加速多项式乘法外基本就没什么用。也就是说，如果我们真的想要让点值表示法加速多项式乘法的方法变得实用，首先需要快速将常见的系数表示法转换为点值表示法。那么我们就要选取$n$个点，然后分别计算对应的$F(x)$，复杂度为$O(n^2)$……好像还不如直接算(っ °Д °;)っ。所以，我们需要一个能够快速把系数表示法转换为点值表示法的算法，也就是——快速傅里叶变换（FFT）
（以下有关傅里叶变换部分，由于笔者既不是通信专业也不是数学专业，对傅里叶变换并不了解，可能会有错误的地方，讲的也不是很专业≧ ﹏ ≦）

### 离散傅里叶变换

关于傅里叶变换，建议先看3b1b和真理元素的这两个视频来理解：
[【【官方双语】形象展示傅里叶变换】](https://www.bilibili.com/video/BV1pW411J7s8/?share_source=copy_web&vd_source=11f2ff5363d8ac30a1bb9e9423c2c36d)
[【这个算法改变了世界】](https://www.bilibili.com/video/BV1CY411R7bA/?share_source=copy_web)

---

既然有快速傅里叶变换，就肯定有不快速的傅里叶变换，也就是离散傅里叶变换（DFT），设$\{x_n\}^{N-1}_{n=0}$，是满足有限性条件的序列，DFT的公式如下——
$$
\hat{x}[k]=\sum\limits^{N-1}\limits_{n=0}{x_ne^{-i\frac{2\pi}{N}nk}}\qquad k=0,1,\cdots,N-1
$$
其中$e$是自然常数，$i$是虚数单位。关于这个式子，上述两个视频已经解释的很清楚，在此只做一个简单的说明。
离散傅里叶变换是将离散的信号从时域信息转换为频域信息，要做到这一点，我们需要把原序列分别与$n$种频率的正弦波和余弦波相乘并积分，由于三角函数的正交性，只有所乘的频率在原信号中存在时其积分才不为0，当然由于信号是离散的所以积分就表现为求和，然后通过欧拉公式
$$
e^{ix}=cos(x)+isin(x)
$$
将与正余弦波分别相乘转换为乘一个复数。因为要分别将$n$个点与$n$条正余弦波相乘，其复杂度显然为$O(n^2)$。

那么这跟多项式有什么关系呢？不难发现（反正我没发现……），如果我们把$x_n$看作多项式的第$n$项的系数，那么上式就相当于$F(e^{-i\frac{2\pi}{N}k})$，也就是$F(x)$的点值表示。也就是说，离散傅里叶变换可以用来求多项式的点值表示。当然复杂度跟暴力没什么区别，所以真正使用时用的都是优化后的快速傅里叶变换。

### 快速傅里叶变换

首先，我们可以通过一个简单的例子来理解快速傅里叶变换的思想。

假如现在有一个偶函数$F(x)$，我们想要知道其上的$n$个点的值，每次询问可以得到一个$x$对应的$F(x)$，那么我们需要几次？
答案显然是$\frac{n}{2}$，因为当我们询问一个$x$，对应也可以知道$F(-x)$的值，对于奇函数也是同理。

那么再把目光转回多项式，对于一个多项式$F(x)=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}$，我们可以把奇数项和偶数项分开（假设$n$是偶数），得到
$$
\begin{array}{c}
    a_0+a_2x^2+\cdots+a_{n-2}x^{n-2} \\
    a_1x^1+a_3x^3+\cdots+a_{n-1}x^{n-1}
\end{array}
$$
显然第一个式子是偶函数，第二个是奇函数，也就是说，我们可以用前面提到的技巧，只用一次询问就得到两个值，于此同时，还可以把眼界打开，令$y=x^2$，从第二个式子中提出一个$x$，就可以得到
$$
\begin{array}{c}
    a_0+a_2y+\cdots+a_{n-2}y^{\frac{n-2}{2}} \\
    x(a_1+a_3y+\cdots+a_{n-1}y^{\frac{n-1}{2}})
\end{array}
$$
于是我们又得到了两个多项式，然后无限套娃，
