<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMake学习笔记</title>
      <link href="/posts/43493/"/>
      <url>/posts/43493/</url>
      
        <content type="html"><![CDATA[<p>由于大部分情况下只有在项目创建时才会写一下CMake，甚至在用了项目模板之后连创建的时候也不需要写，因此老是忘记一些东西要怎么写，故写个笔记方便以后查看。目前只记录一些最常用的函数，后续再逐渐补充，并添加一些教程。</p><h2 id="特性">特性</h2><ul><li>在CMake中不论Linux还是Windows都使用<code>/</code>作为路径分割符</li></ul><h2 id="常用函数">常用函数</h2><h3 id="通用函数">通用函数</h3><ul><li><p><code>cmake_minimum_required</code><br>这个函数用来指定脚本所需的CMake最低版本，比如你用到了一些高版本CMake的语法，就可以用这个函数来指定最低版本，一般放在CMakeLists.txt的第一行，比如<code>cmake_minimum_required(VERSION 3.13)</code>。</p></li><li><p><code>project</code><br>指定项目名称，LANGUAGES字段可以指定项目使用的语言，目前支持以下语言：</p><ul><li>C，C语言</li><li>CXX，C++</li><li>ASM，汇编</li><li>Fortran，Fortran语言</li><li>CUDA，英伟达的CUDA</li><li>OBJC，苹果的Objective-C</li><li>OBJCXX，苹果的Objective-C++</li><li>ISPC，一种英特尔的自动SIMD编程语言<br>VERSION字段可以指定项目版本，CMake使用x.y.z这样的版本号，<br>简单的示例<code>project(test LANGUAGES CXX C)</code>。</li></ul></li><li><p><code>message</code><br>输出信息，可以指定信息类型，支持以下类型</p><ul><li>STATUS 正常的信息</li><li>WARNING 输出警告，不会中断脚本</li><li>AUTHOR_WARNING 只对作者的警告，可以通过命令行<code>-Wno-dev</code>关闭</li><li>SEND_ERROR 错误，会中断构建，但会继续执行脚本</li><li>FATAL_ERROR 错误，会中断脚本运行<br>简单示例<code>message(STATUS &quot;sources: $&#123;sources&#125;&quot;)</code></li></ul></li><li><p><code>set</code><br>这个函数用来定义变量，比如<code>set(sources main.cpp)</code>，即定义一个sources变量存储main.cpp文件。通过<code>$&#123;sources&#125;</code>来使用变量。除了自定义变量外，也可以用来改变CMake内置变量的值，比如<code>set(CMAKE_CXX_STANDARD 20)</code>，即设置C++标准为C++20，使用CMAKE开头的一般都是CMake的内置变量，用来定义相关的配置。</p></li></ul><h3 id="文件相关">文件相关</h3><ul><li><code>file</code><br>这个函数用来批量查找文件，比如<code>file(GLOB sources *.cpp *.h)</code>，就会搜索所有后缀为cpp和h的文件，并存在sources变量中。把GLOB改为GLOB_RECURSE就会递归的搜索子目录。在大型项目中一般不使用，因为不会自动添加文件，如果新增了文件需要重新配置cmake，并且文件数量过多时可能导致性能问题，当然个人项目还是很方便的，可以使用CONFIGURE_DEPENDS选项来自动更新文件列表，比如<code>file(GLOB sources CONFIGURE_DEPENDS *.cpp)</code>。</li></ul><h3 id="库相关">库相关</h3><ul><li><code>add_library</code><br>添加一个库，可以选择静态库还是动态库。<br>简单示例</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib STATIC mylib.cpp) <span class="comment"># 静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp) <span class="comment"># 动态库</span></span><br></pre></td></tr></table></figure><p>除了常规的静态库动态库外，CMake还可以使用一种特殊的对象库，对象库和静态库类似，但是不生成静态库文件，只是CMake内部组织代码的一种方式，可以认为是一种逻辑上的库。使用方式<code>add_library(mylib OBJECT mylib.cpp)</code>。</p><ul><li><code>find_package</code><br>查找指定库文件并生成伪对象，可以用<code>COMPONENTS</code>指定组件，<code>REQUIRED</code>指定找不到时报错。在linux下，这个函数会在<code>/usr/lib/cmake</code>目录下寻找对应库的配置文件（{包名}Config.cmake，例如ClangConfig.cmake），生成伪对象，包含了include路径等信息，在链接时这些配置会扩散到构建目标上，无需单独配置。在Windows上则需要额外的配置，推荐的做法是定义<code>&#123;包名&#125;_DIR</code>的变量指向配置文件所在路径，比如定义<code>Qt5_DIR</code>指向<code>D:/Qt/5.15.2/msvc2019_64/lib/cmake</code>。对于Qt这种有多个组件的库，必须指定组件。<br>简单示例</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 REQUIRED COMPONENTS Core Gui Widgets)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> main.cpp mainwindow.h mainwindow.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">test</span> PUBLIC Qt5::Core Qt5::Gui Qt5::Widgets)</span><br></pre></td></tr></table></figure><h3 id="构建相关">构建相关</h3><ul><li><code>add_executable</code><br>这个函数用来添加一个可执行文件作为构建目标，比如<code>add_executable(main main.cpp)</code>，就是使用main.cpp文件构建main这个可执行文件，可以用空格分割多个文件。</li></ul><h3 id="target-相关函数">target_ 相关函数</h3><p>这个系列的函数都是作用与一个对象</p><ul><li><code>target_sources</code><br>给目标添加源文件，简单示例</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">target_sources</span>(main main.cpp)</span><br></pre></td></tr></table></figure><ul><li><code>target_link_libraries</code><br>给目标链接库。</li></ul><h2 id="命令行">命令行</h2><ul><li><p><code>cmake -B</code><br>指定build目录，一般用法为<code>cmake -B build</code>，会自动创建build目录并生成项目文件</p></li><li><p><code>cmake --build</code><br>开始构建，一般用法为<code>cmake --build build</code></p></li><li><p><code>cmake -D</code><br>配置CMake变量，比如<code>cmake -DCMAKE_BUILD_TYPE=Release</code>，即设置构建类型为release。-D指令设置的是缓存变量，也就是说会写入CMakeCache.txt，下一次执行cmake命令时就不需要再次设置。</p></li><li><p><code>cmake -G</code><br>指定生成器，比如<code>cmake -GNinja</code>，若不指定，则在Linux上默认使用Makefile，Windows上默认使用MSBuild。由于Ninja跨平台，性能好，一般都使用Ninja。</p></li></ul><h2 id="内置变量">内置变量</h2><ul><li><p><code>CMAKE_BUILD_TYPE</code><br>指定构建类型，有以下四种：</p><ul><li>Debug 调试模式，包含调试信息</li><li>Release 发布模式，优化程度最高</li><li>MinSizeRel 最小体积发布，生成文件较Release小，节省空间</li><li>RelWithDebInfo 带调试信息的发布，较Release比多了调试信息</li></ul></li></ul><p>默认空字符串，此时为Debug模式。</p><ul><li><p><code>CMAKE_CURRENT_SOURCE_DIR</code><br>当前CMakeLists.txt所在的路径</p></li><li><p><code>CMAKE_CURRENT_BINARY_DIR</code><br>当前输出目录的位置</p></li><li><p><code>PROJECT_SOURCE_DIR</code><br>当前项目的源文件路径，也就是使用了<code>project</code>的CMakeLists.txt所在的路径。</p></li><li><p><code>PROJECT_NAME</code><br>当前项目名</p></li><li><p><code>PROJECT_VERSION</code><br>当前项目版本号</p></li><li><p><code>CMAKE_CXX_STANDARD</code><br>C++标准版本</p></li><li><p><code>CMAKE_CXX_STANDARD_REQUIRED</code><br>BOOL类型的变量，表示是否一定要支持设定的C++标准，若设置为ON则会在编译器不支持时报错。</p></li><li><p><code>CMAKE_CXX_EXTENSIONS</code><br>是否支持编译器扩展，比如GCC支持C99的一些特殊写法，但这些写法在标准C++里是没有的，如果要兼容性就会设置为OFF。</p></li></ul><h2 id="基本使用">基本使用</h2><p>一个简单的CMake脚本主要由以下几个部分组成</p><ol><li>配置基本设置，如cmake版本要求，C++标准，项目名等</li><li>寻找三方库</li><li>收集源文件</li><li>添加构建目标</li><li>链接库</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客暑期多校第一场I-Mirror Maze</title>
      <link href="/posts/52837/"/>
      <url>/posts/52837/</url>
      
        <content type="html"><![CDATA[<p>花了我将近两天时间Debug的阴间题，写完感觉人生都空虚了（；´д｀）ゞ</p><hr><p>题意还是很简单的，思路也很明显，就是记忆化搜索，或者像题解一样直接都预处理出来。<br>这题的图跟一般的图主要的区别在于图中的环是无法从外部进入的，因为光路是可逆的，所以光路只有两种可能，要么在一个环中死循环，要么形成一条链最后射出边界，虽然听起来很简单，但是我写了整整三个版本的代码，前两个版本都是没有考虑全面导致实现有问题，都是过60%，其中一个在我找出一个错误样例并改对后信心满满的交了一发之后从过60变成了过30……</p><p>下面是翻车经历：</p><p>最开始的时候我只开了两个数组，一个记录是否被访问，一个记录答案，然后发现一面镜子可能在一条路径中被访问多次，于是又开了一个数组记录路径编号，交一发喜提wa（以下代码都经过多次修改，我也不确定是不是当初交的那一版_(:з)∠)_）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">using</span> std::cin, std::cout, std::string;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = std::pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i], a[i] = <span class="string">&quot; &quot;</span> + a[i] + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector <span class="title">F</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;std::array&lt;<span class="type">int</span>, <span class="number">4</span>&gt;&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="function">std::vector <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;std::array&lt;<span class="type">int</span>, <span class="number">4</span>&gt;&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="function">std::vector <span class="title">id</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;std::array&lt;<span class="type">int</span>, <span class="number">4</span>&gt;&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>]&#123;</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    std::map&lt;<span class="type">char</span>, std::array&lt;<span class="type">int</span>, 4&gt;&gt; mp&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;/&#x27;</span>, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;\\&#x27;</span>, &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;|&#x27;</span>, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;-&#x27;</span>, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;&#125;;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; mp1&#123;</span><br><span class="line">        &#123;<span class="string">&quot;above&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;below&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;left&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;right&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tag = <span class="number">1</span>, lst = <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt; is;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;self, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v) -&gt; std::pair&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (F[x][y][v]) &#123;</span><br><span class="line">            tag = id[x][y][v];</span><br><span class="line">            <span class="keyword">return</span> &#123;F[x][y][v], <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> xx = x + d[v][<span class="number">0</span>], yy = y + d[v][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || xx &gt; n || yy &lt; <span class="number">1</span> || yy &gt; m) &#123;</span><br><span class="line">            tag = ++lst;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; std::format(&quot;x:&#123;&#125; y:&#123;&#125; v:&#123;&#125;\n&quot;, x, y, v);</span></span><br><span class="line">        <span class="type">int</span> vv = mp[a[xx][yy]][v];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis[xx][yy][vv] == tag) &#123;</span><br><span class="line">            tag = ++lst;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[xx][yy][vv] = tag;</span><br><span class="line">        <span class="keyword">auto</span> [t, flag] = <span class="built_in">self</span>(self, xx, yy, vv);</span><br><span class="line">        F[x][y][v] = (!(<span class="type">bool</span>)std::<span class="built_in">count</span>(id[xx][yy].<span class="built_in">begin</span>(), id[xx][yy].<span class="built_in">end</span>(), tag) &amp;&amp; v != vv);</span><br><span class="line">        id[xx][yy][vv] = tag;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            is.<span class="built_in">push_back</span>(&#123;x, y, v&#125;);</span><br><span class="line">        <span class="keyword">return</span> &#123;F[x][y][v] += t, flag&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        std::string s;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; s;</span><br><span class="line">        tag = ++lst;</span><br><span class="line">        <span class="keyword">auto</span> [ans, flag] = <span class="built_in">dfs</span>(dfs, u, v, mp1[s]);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, v] : is)</span><br><span class="line">                F[x][y][v] = ans;</span><br><span class="line">            is.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后调了半天，发现对于有的镜子在同一条路径上可能会同时以反射镜和非反射镜出现，比如下面这个样例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">----|</span><br><span class="line">//--\</span><br><span class="line">\---/</span><br><span class="line">1</span><br><span class="line">1 2 below</span><br></pre></td></tr></table></figure><p>其中<code>[3][2]</code>处的镜子就是同时以两种形式出现的，但是我判断是否重复时直接判断的是否出现，而不是是否作为反射镜出现。其实这一版已经很接近答案了，但是我当时一拍脑袋，直接用一个外部的<code>set</code>去重不就行了？于是就有了第二版代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">using</span> std::cin, std::cout, std::string;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = std::pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i], a[i] = <span class="string">&quot; &quot;</span> + a[i] + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector <span class="title">F</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;std::array&lt;<span class="type">int</span>, <span class="number">4</span>&gt;&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="function">std::vector <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;std::array&lt;<span class="type">int</span>, <span class="number">4</span>&gt;&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>]&#123;</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    std::map&lt;<span class="type">char</span>, std::array&lt;<span class="type">int</span>, 4&gt;&gt; mp&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;/&#x27;</span>, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;\\&#x27;</span>, &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;|&#x27;</span>, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;-&#x27;</span>, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;&#125;;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; mp1&#123;</span><br><span class="line">        &#123;<span class="string">&quot;above&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;below&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;left&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;right&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt; st;</span><br><span class="line">    std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; ok;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;self, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v, <span class="type">int</span> tag) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        st.<span class="built_in">push_back</span>(&#123;x, y, v&#125;);</span><br><span class="line">        <span class="keyword">if</span> (F[x][y][v]) &#123;</span><br><span class="line">            ans += F[x][y][v];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; std::format(&quot;x:&#123;&#125;, y:&#123;&#125;, v:&#123;&#125;\n&quot;, x, y, v);</span></span><br><span class="line">        <span class="type">int</span> xx = x + d[v][<span class="number">0</span>], yy = y + d[v][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || xx &gt; n || yy &lt; <span class="number">1</span> || yy &gt; m)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">        <span class="type">int</span> vv = mp[a[xx][yy]][v];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vv != v)</span><br><span class="line">            ok.<span class="built_in">insert</span>(&#123;xx, yy&#125;);</span><br><span class="line">        <span class="keyword">if</span> (vis[xx][yy][vv] == tag)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        vis[xx][yy][vv] = tag;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>(self, xx, yy, vv, tag);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> _u, _v;</span><br><span class="line">        std::string op;</span><br><span class="line">        cin &gt;&gt; _u &gt;&gt; _v &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> vv = mp1[op];</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// vis[_u][_v][vv] = ++idx;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(dfs, _u, _v, vv, idx)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, v] : st)</span><br><span class="line">                F[x][y][v] = ok.<span class="built_in">size</span>();</span><br><span class="line">            st.<span class="built_in">clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; s;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y, v] = st.<span class="built_in">back</span>();</span><br><span class="line">                F[x][y][v] = s.<span class="built_in">size</span>() + ans;</span><br><span class="line">                <span class="keyword">if</span> (ok.<span class="built_in">count</span>(&#123;x, y&#125;))</span><br><span class="line">                    s.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">                st.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ok.<span class="built_in">clear</span>();</span><br><span class="line">        std::cout &lt;&lt; F[_u][_v][vv] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一版代码里面，我直接把<code>dfs</code>返回的答案都去掉了，只用来判断是否是环，由于光路不会出现分叉，所以可以用一个外部的栈记录链上的镜子出现的顺序，然后逆推答案，只需要把所有在本次搜索中作为反射镜的点都存到<code>set</code>里，逆推时判断。<br>改完后调过了几个样例，感觉很对，一交60变30，寄。</p><p>这个版本的问题主要在于一条链可能是分几次走的，也就是一次询问走了后半部分，下一次询问又从前半部分开始，由于对于走过的点只存了一个答案，而丢失了路径信息，有可能一个点在后半部分已经经过了一次，但是由于第二次从前面开始时无法知道后面走过了哪些点，就会重复计算，并且无法去重。</p><p>经过一天的调试，我确定必须要给每条路径一个编号，来判断是否重复出现，同时也需要记录是否访问，否则碰到环就会死循环，于是又回到了第一版代码，又调试了一两个小时，对拍了几次，终于过了这个抽象题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">using</span> std::cin, std::cout, std::string;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = std::pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i], a[i] = <span class="string">&quot; &quot;</span> + a[i] + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector <span class="title">F</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;std::array&lt;<span class="type">int</span>, <span class="number">4</span>&gt;&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="function">std::vector <span class="title">id</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;std::array&lt;<span class="type">int</span>, <span class="number">4</span>&gt;&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="function">std::vector <span class="title">used</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;std::array&lt;<span class="type">int</span>, <span class="number">4</span>&gt;&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>]&#123;</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    std::map&lt;<span class="type">char</span>, std::array&lt;<span class="type">int</span>, 4&gt;&gt; mp&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;/&#x27;</span>, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;\\&#x27;</span>, &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;|&#x27;</span>, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;-&#x27;</span>, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;&#125;;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; mp1&#123;</span><br><span class="line">        &#123;<span class="string">&quot;above&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;below&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;left&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;right&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tag = <span class="number">1</span>, lst = <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt; is;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;self, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v) -&gt; std::pair&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) &#123;</span><br><span class="line">            <span class="comment">// 越界说明是一条新的链，分配新的编号</span></span><br><span class="line">            tag = ++lst;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (F[x][y][v]) &#123;</span><br><span class="line">            <span class="comment">// 说明后面的链是之前走过的，把编号设置为对应的编号</span></span><br><span class="line">            tag = id[x][y][v];</span><br><span class="line">            <span class="keyword">return</span> &#123;F[x][y][v], <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (id[x][y][v] == tag) &#123;</span><br><span class="line">            <span class="comment">// 在本次递归中访问过，说明是环</span></span><br><span class="line">            tag = ++lst;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> vv = mp[a[x][y]][v];</span><br><span class="line">        <span class="type">int</span> xx = x + d[vv][<span class="number">0</span>], yy = y + d[vv][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; std::format(&quot;x:&#123;&#125; y:&#123;&#125; v:&#123;&#125;\n&quot;, x, y, v);</span></span><br><span class="line"></span><br><span class="line">        id[x][y][v] = tag; <span class="comment">// 临时编号</span></span><br><span class="line">        <span class="keyword">auto</span> [t, flag] = <span class="built_in">self</span>(self, xx, yy, vv);</span><br><span class="line">        <span class="keyword">if</span> (v != vv) &#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            F[x][y][v] = !(<span class="type">bool</span>)std::<span class="built_in">count</span>(used[x][y].<span class="built_in">begin</span>(), used[x][y].<span class="built_in">end</span>(), tag);</span><br><span class="line">            used[x][y][v] = tag;</span><br><span class="line">        &#125;</span><br><span class="line">        id[x][y][v] = tag; <span class="comment">// 真正的路径编号</span></span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            is.<span class="built_in">push_back</span>(&#123;x, y, v&#125;);</span><br><span class="line">        <span class="keyword">return</span> &#123;F[x][y][v] += t, flag&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        std::string s;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> vv = mp1[s];</span><br><span class="line">        u += d[vv][<span class="number">0</span>], v += d[vv][<span class="number">1</span>];</span><br><span class="line">        tag = ++lst; <span class="comment">// 分配临时编号</span></span><br><span class="line">        <span class="keyword">auto</span> [ans, flag] = <span class="built_in">dfs</span>(dfs, u, v, vv);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 环单独处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, v] : is)</span><br><span class="line">                F[x][y][v] = ans;</span><br><span class="line">            is.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⡷⣯⢿⣿⣷⣻⢯⣿⡽⣻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠸⣿⣿⣆⠹⣿⣿⢾⣟⣯⣿⣿⣿⣿⣿⣿⣽⣻⣿⣿⣿⣿⣿⣿⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣻⣽⡿⣿⣎⠙⣿⣞⣷⡌⢻⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⡄⠹⣿⣿⡆⠻⣿⣟⣯⡿⣽⡿⣿⣿⣿⣿⣽⡷⣯⣿⣿⣿⣿⣿⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣟⣷⣿⣿⣿⡀⠹⣟⣾⣟⣆⠹⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢠⡘⣿⣿⡄⠉⢿⣿⣽⡷⣿⣻⣿⣿⣿⣿⡝⣷⣯⢿⣿⣿⣿⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣯⢿⣾⢿⣿⡄⢄⠘⢿⣞⡿⣧⡈⢷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣧⠘⣿⣷⠈⣦⠙⢿⣽⣷⣻⣽⣿⣿⣿⣿⣌⢿⣯⢿⣿⣿⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣟⣯⣿⢿⣿⡆⢸⡷⡈⢻⡽⣷⡷⡄⠻⣽⣿⣿⡿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣏⢰⣯⢷⠈⣿⡆⢹⢷⡌⠻⡾⢋⣱⣯⣿⣿⣿⣿⡆⢻⡿⣿⣿⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⡎⣿⢾⡿⣿⡆⢸⣽⢻⣄⠹⣷⣟⣿⣄⠹⣟⣿⣿⣟⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⢸⣯⣟⣧⠘⣷⠈⡯⠛⢀⡐⢾⣟⣷⣻⣿⣿⣿⡿⡌⢿⣻⣿⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣧⢸⡿⣟⣿⡇⢸⣯⣟⣮⢧⡈⢿⣞⡿⣦⠘⠏⣹⣿⣽⢿⣿⣿⣿⣿⣯⣿⣿⣿⡇⢸⣿⣿⣾⡆⠹⢀⣠⣾⣟⣷⡈⢿⣞⣯⢿⣿⣿⣿⢷⠘⣯⣿⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣿⡈⣿⢿⣽⡇⠘⠛⠛⠛⠓⠓⠈⠛⠛⠟⠇⢀⢿⣻⣿⣯⢿⣿⣿⣿⣷⢿⣿⣿⠁⣾⣿⣿⣿⣧⡄⠇⣹⣿⣾⣯⣿⡄⠻⣽⣯⢿⣻⣿⣿⡇⢹⣾⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣿⡇⢹⣿⡽⡇⢸⣿⣿⣿⣿⣿⣞⣆⠰⣶⣶⡄⢀⢻⡿⣯⣿⡽⣿⣿⣿⢯⣟⡿⢀⣿⣿⣿⣿⣿⣧⠐⣸⣿⣿⣷⣿⣿⣆⠹⣯⣿⣻⣿⣿⣿⢀⣿⢿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣿⣿⠘⣯⡿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣧⡈⢿⣳⠘⡄⠻⣿⢾⣽⣟⡿⣿⢯⣿⡇⢸⣿⣿⣿⣿⣿⣿⡀⢾⣿⣿⣿⣿⣿⣿⣆⠹⣾⣷⣻⣿⡿⡇⢸⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣿⣿⡇⢹⣿⠇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠻⡇⢹⣆⠹⣟⣾⣽⣻⣟⣿⣽⠁⣾⣿⣿⣿⣿⣿⣿⣇⣿⣿⠿⠛⠛⠉⠙⠋⢀⠁⢘⣯⣿⣿⣧⠘⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣿⣿⣿⡈⣿⡃⢼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡙⠌⣿⣆⠘⣿⣞⡿⣞⡿⡞⢠⣿⣿⣿⣿⣿⡿⠛⠉⠁⢀⣀⣠⣤⣤⣶⣶⣶⡆⢻⣽⣞⡿⣷⠈⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠘⠁⠉⠉⠉⠉⠉⠉⠉⠉⠉⠙⠛⠛⢿⣄⢻⣿⣧⠘⢯⣟⡿⣽⠁⣾⣿⣿⣿⣿⣿⡃⢀⢀⠘⠛⠿⢿⣻⣟⣯⣽⣻⣵⡀⢿⣯⣟⣿⢀⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣟⣿⣿⣿⣿⣶⣶⡆⢀⣿⣾⣿⣾⣷⣿⣶⠿⠚⠉⢀⢀⣤⣿⣷⣿⣿⣷⡈⢿⣻⢃⣼⣿⣿⣿⣿⣻⣿⣿⣿⡶⣦⣤⣄⣀⡀⠉⠛⠛⠷⣯⣳⠈⣾⡽⣾⢀⣿</span></span><br><span class="line"><span class="comment">⣿⢿⣿⣿⣻⣿⣿⣿⣿⣿⡿⠐⣿⣿⣿⣿⠿⠋⠁⢀⢀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣌⣥⣾⡿⣿⣿⣷⣿⣿⢿⣷⣿⣿⣟⣾⣽⣳⢯⣟⣶⣦⣤⡾⣟⣦⠘⣿⢾⡁⢺</span></span><br><span class="line"><span class="comment">⣿⣻⣿⣿⡷⣿⣿⣿⣿⣿⡗⣦⠸⡿⠋⠁⢀⢀⣠⣴⢿⣿⣽⣻⢽⣾⣟⣷⣿⣟⣿⣿⣿⣳⠿⣵⣧⣼⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣽⣳⣯⣿⣿⣿⣽⢀⢷⣻⠄⠘</span></span><br><span class="line"><span class="comment">⣿⢷⣻⣿⣿⣷⣻⣿⣿⣿⡷⠛⣁⢀⣀⣤⣶⣿⣛⡿⣿⣮⣽⡻⣿⣮⣽⣻⢯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⢀⢸⣿⢀⡆</span></span><br><span class="line"><span class="comment">⠸⣟⣯⣿⣿⣷⢿⣽⣿⣿⣷⣿⣷⣆⠹⣿⣶⣯⠿⣿⣶⣟⣻⢿⣷⣽⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣯⣟⢀⡇</span></span><br><span class="line"><span class="comment">⣇⠹⣟⣾⣻⣿⣿⢾⡽⣿⣿⣿⣿⣿⣆⢹⣶⣿⣻⣷⣯⣟⣿⣿⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢀⡿⡇⢸⡇</span></span><br><span class="line"><span class="comment">⣿⣆⠹⣷⡻⣽⣿⣯⢿⣽⣻⣿⣿⣿⣿⣆⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⢸⣿⠇⣼⡇</span></span><br><span class="line"><span class="comment">⡙⠾⣆⠹⣿⣦⠛⣿⢯⣷⢿⡽⣿⣿⣿⣿⣆⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠎⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⢀⣿⣾⣣⡿⡇</span></span><br><span class="line"><span class="comment">⣿⣷⡌⢦⠙⣿⣿⣌⠻⣽⢯⣿⣽⣻⣿⣿⣿⣧⠩⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⢰⢣⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⢀⢀⢿⣞⣷⢿⡇</span></span><br><span class="line"><span class="comment">⣿⣽⣆⠹⣧⠘⣿⣿⡷⣌⠙⢷⣯⡷⣟⣿⣿⣿⣷⡀⡹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣈⠃⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢀⣴⡧⢀⠸⣿⡽⣿⢀</span></span><br><span class="line"><span class="comment">⢻⣽⣿⡄⢻⣷⡈⢿⣿⣿⢧⢀⠙⢿⣻⡾⣽⣻⣿⣿⣄⠌⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⢁⣰⣾⣟⡿⢀⡄⢿⣟⣿⢀</span></span><br><span class="line"><span class="comment">⡄⢿⣿⣷⢀⠹⣟⣆⠻⣿⣿⣆⢀⣀⠉⠻⣿⡽⣯⣿⣿⣷⣈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⢀⣠⠘⣯⣷⣿⡟⢀⢆⠸⣿⡟⢸</span></span><br><span class="line"><span class="comment">⣷⡈⢿⣿⣇⢱⡘⢿⣷⣬⣙⠿⣧⠘⣆⢀⠈⠻⣷⣟⣾⢿⣿⣆⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⣠⡞⢡⣿⢀⣿⣿⣿⠇⡄⢸⡄⢻⡇⣼</span></span><br><span class="line"><span class="comment">⣿⣷⡈⢿⣿⡆⢣⡀⠙⢾⣟⣿⣿⣷⡈⠂⠘⣦⡈⠿⣯⣿⢾⣿⣆⠙⠻⠿⠿⠿⠿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⢋⣠⣾⡟⢠⣿⣿⢀⣿⣿⡟⢠⣿⢈⣧⠘⢠⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣄⠻⣿⡄⢳⡄⢆⡙⠾⣽⣿⣿⣆⡀⢹⡷⣄⠙⢿⣿⡾⣿⣆⢀⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣀⣠⣴⡿⣯⠏⣠⣿⣿⡏⢸⣿⡿⢁⣿⣿⢀⣿⠆⢸⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣦⡙⣿⣆⢻⡌⢿⣶⢤⣉⣙⣿⣷⡀⠙⠽⠷⠄⠹⣿⣟⣿⣆⢙⣋⣤⣤⣤⣄⣀⢀⢀⢀⢀⣾⣿⣟⡷⣯⡿⢃⣼⣿⣿⣿⠇⣼⡟⣡⣿⣿⣿⢀⡿⢠⠈⣿</span></span><br><span class="line"><span class="comment">⣿⣿⣿⣿⣿⣷⣮⣿⣿⣿⡌⠁⢤⣤⣤⣤⣬⣭⣴⣶⣶⣶⣆⠈⢻⣿⣿⣆⢻⣿⣿⣿⣿⣿⣿⣷⣶⣤⣌⣉⡘⠛⠻⠶⣿⣿⣿⣿⡟⣰⣫⣴⣿⣿⣿⣿⠄⣷⣿⣿⣿</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其中，<code>F[x][y][v]</code>表示从点<code>[x][y]</code>以方向<code>v</code>射入的答案，由于环不同于链，环上的点答案都是相同的，所以需要在搜索完后单独处理，为了判定是出现了环还是走到了之前走过的点，<code>dfs</code>的返回值需要有一个布尔值。<code>id</code>是这个点所在的路径的编号，<code>used</code>是反射镜所在路径的编号，由于之前说过的同时以反射镜和非反射镜出现的情况，对于反射镜必须单独开一个数组。<br>总结来说，递归的主要目的其实就两个：</p><ol><li>确定是否是环</li><li>确定当前的链是一条之前没走过的链还是后半部分是之前走过的链</li></ol><p>为了确定这一点，需要在递归完成后再进行编号，如果是之前走过的链，就让<code>tag</code>等于那条链对应的编号，否则就分配一个新的编号，然后在回溯时将编号赋值给访问到的所有点，同时根据反射前后的方向判断当前镜子是否是反射镜，是就标记上当前的路径编号，由于一面镜子也可能同时作为两条路径的反射镜，所以所有标记数组都需要记录方向。<br>除此之外，虽然编号要在回溯时才能确定，但标记要在递归前标记，否则就无法判断是否是环，为此，可以在单独开一个数组用于标记，或者像我一样分配一个临时编号，实测可以少50ms（其实也没什么用(～￣▽￣)～）具体的步骤都在代码里有注释。</p><hr><p>其实最后总结一下也没有那么多东西要考虑，单纯之前考虑不够全面导致一直wa还把接近答案的代码抛弃换了一个全新的写法，考虑清楚之后做法还是很清晰的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>可持久化数据结构</title>
      <link href="/posts/55889/"/>
      <url>/posts/55889/</url>
      
        <content type="html"><![CDATA[<p>可持久化数据结构是指在每次修改后都保存了修改前版本的数据结构。在可持久化数据结构中，我们可以很方便的追溯到某次修改前的版本，以此来完成某些操作。简单来说，对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>次插入操作，我们就存储<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个版本，第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>个版本对应了前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>次操作后的数据结构。当然，不可能真的存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个完全独立的版本，空间会直接爆炸(～￣▽￣)～。可以注意到，对于Trie和线段树等数据结构来说，每次插入只改变了一条链上的节点，因此对于每次插入操作，我们只需要新建这条链上的节点，而其他的节点可以直接白嫖上一个版本的。<br>常用的可持久化数据结构主要有可持久化的Trie和可持久化线段树。</p><h2 id="可持久化Trie">可持久化Trie</h2><p>首先，既然有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个版本，当然就对应了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个根节点，从不同的根节点开始遍历就可以得到不同版本的数据结构。下面简单演示一下可持久化Trie的插入过程。<br>最开始是一个空的Trie，插入一个字符串no（黑色节点表示根节点）<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/sis_trie_1.png" alt="trie_1"><br>然后插入一个字符串game，由于这整个字符串都属于要改变的节点，所以都要新建，同时，为了从新建的根节点能够访问到以前插入的字符串，新的根节点也要有边连向n<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/sis_trie_2.png" alt="trie_2"><br>继续再插入一个字符串no，但是no之前已经插入过了，如果是一般的Trie，那么插入之后不会有变化，但是对于可持久化Trie来说，不论之前有没有，新插入的字符串都需要再开新的节点存储<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/sis_trie_3.png" alt="trie_3"><br>最后插入字符串life<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/sis_trie_4.png" alt="trie_4"><br>从上面的演示可以看出，从对应版本的根节点开始遍历，就可以得到这个版本的对应的Trie，而不会遍历到在这之后插入的节点。<br>具体的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际占据空间为所有字符串长度和（每次插入都要创建新节点）加上字符串数量（每次都要创建一个根节点）</span></span><br><span class="line"><span class="type">int</span> tr[N + M + <span class="number">10</span>][<span class="number">26</span>], tot;</span><br><span class="line"><span class="comment">// 每个版本的根节点</span></span><br><span class="line"><span class="type">int</span> rt[N + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// p表示上一个版本的根节点，q为当前版本的根节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(std::string &amp;s, <span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">        <span class="type">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 从上一个版本继承节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            tr[q][i] = tr[p][i];</span><br><span class="line">        <span class="comment">// 为当前节点创建新节点</span></span><br><span class="line">        tr[q][c] = ++tot;</span><br><span class="line">        <span class="comment">// 同时移动两个指针，因为需要将后续的节点也复制过来</span></span><br><span class="line">        p = tr[p][c], q = tr[q][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    rt[i] = ++tot; <span class="comment">// 创建新的根节点</span></span><br><span class="line">    <span class="built_in">insert</span>(a[i], rt[i - <span class="number">1</span>], rt[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一道例题：<a href="https://www.luogu.com.cn/problem/P4735">https://www.luogu.com.cn/problem/P4735</a><br>首先看到区间异或和，自然想到前缀和做法，而01Trie则可以找出最大的异或和，那么如何限制<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>呢？我们可以使用可持久化Trie，由于当从第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>个根节点开始遍历时只会遍历到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>的数字，这样就限制了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>。接下来就是限制<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>，注意到对于每次插入可持久化Trie都会创建新的节点，所以对于每一个数字中的每一位，在01Trie中其实都有唯一一个节点与其对应，后面的节点都只是在引用这个节点，而一般的Trie由于公共前缀只存储一个，所以没有这样的一一对应关系。因此，我们可以在每个节点上再存储一个信息，即这个节点是作为第几个数字被插入的，这样在遍历寻找时，只需要判断一下是否大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>，就能保证遍历的范围限定在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// lst即节点是作为第几个数字被插入的</span></span><br><span class="line"><span class="type">int</span> tr[N * <span class="number">25</span>][<span class="number">2</span>], lst[N * <span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> insert = [&amp;](<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> p, <span class="type">int</span> q) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> b = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">            tr[q][!b] = tr[p][!b];</span><br><span class="line">            tr[q][b] = ++tot;</span><br><span class="line">            lst[tr[q][b]] = idx;</span><br><span class="line">            p = tr[p][b], q = tr[q][b];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">rt</span><span class="params">(n + m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    rt[<span class="number">0</span>] = ++tot, lst[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 因为rt[0]是有意义的，但节点编号0表示没有，为了让l为0时不会出现误判，lst[0]要设置为-1</span></span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        sum ^= a[i];</span><br><span class="line">        rt[i + <span class="number">1</span>] = ++tot;</span><br><span class="line">        <span class="built_in">insert</span>(i + <span class="number">1</span>, sum, rt[i], rt[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="type">int</span> p = rt[r], res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> b = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里不需要判空，因为没有子节点时lst[0]为-1一定小于l</span></span><br><span class="line">            <span class="keyword">if</span> (lst[tr[p][!b]] &gt;= l)</span><br><span class="line">                p = tr[p][!b], res |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = tr[p][b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            rt[++n] = ++tot;</span><br><span class="line">            sum ^= x;</span><br><span class="line">            <span class="built_in">insert</span>(n, sum, rt[n - <span class="number">1</span>], rt[n]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r, x;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">            x ^= sum;</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">query</span>(l - <span class="number">1</span>, r - <span class="number">1</span>, x) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可持久化线段树">可持久化线段树</h2><p>在单点修改的线段树中，每次修改都只改变了这一条路径上的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>个节点，所以线段树自然也有可持久化版本。其操作也与可持久化Trie类似，改变的节点创建新的节点，不改变的直接继承自上一个版本。下面用区间最值的线段树简单演示一下修改过程。<br>初始状态<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/sis_segtr_1.png" alt="seg_tr_1"><br>将1修改为6，那么对于1到根节点上的所有节点，都需要新建一个节点<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/sis_segtr_2.png" alt="seg_tr_2"><br>虽然有点扭曲，但还是可以看出来第二个线段树的样子的。由于过程基本和可持久化Trie一样<s>主要是图变难画了</s>，在此只演示一次修改。<br>可持久化线段树的插入操作代码如下，由于可持久化线段树内存占用较大，所以可以通过不存储<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，而是直接将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>作为递归参数传递，同时由于后面新建立的线段树不再是完全二叉树，不能直接线性存储，只能动态开点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lc：左儿子，rc：右儿子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建新节点，复制上一个版本</span></span><br><span class="line">    <span class="type">int</span> q = ++tot;</span><br><span class="line">    tr[q] = tr[p];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[q].max = x;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= mid) tr[q].lc = <span class="built_in">insert</span>(i, x, l, mid, tr[p].lc);</span><br><span class="line">    <span class="keyword">else</span> tr[q].rc = <span class="built_in">insert</span>(i, x, mid + <span class="number">1</span>, r, tr[p].rc);</span><br><span class="line">    tr[q].max = std::<span class="built_in">max</span>(tr[tr[q].lc].max, tr[tr[q].rc].max);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主席树">主席树</h2><p>既然都提到了可持久化线段树，那就不得不提一下大名鼎鼎的主席树。<br>主席树的本质其实就是可持久化权值线段树，用来解决区间第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>大之类的问题。首先什么是权值线段树？权值线段树其实就是一个维护数字出现次数的线段树，比如叶子节点的区间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，就表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>出现了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>次，当然实际使用时一般需要离散化，因为权值线段树不关心数字的具体大小。有了权值线段树，我们就可以找出整个数组的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>大，具体来说，每次递归时先判断左边区间里的数字数量是否大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，是则说明第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>大的数在右边，那么就往右儿子递归，同时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>减去左边出现的数字数量，否则往左儿子递归。<br>这是全局的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>大，那么如何限制区间呢。可以使用可持久化线段树，这样从第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>个根节点开始遍历就可以得到前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>个数字的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>大，这样就限制了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>，我们可以使用前缀和的思想来作差，从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个根节点开始遍历，两者相减就可以得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>这段区间中数字出现的次数。<br>具体可以看看模板题<a href="https://www.luogu.com.cn/problem/P3834">https://www.luogu.com.cn/problem/P3834</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lc, rc;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line">Node tr[N * <span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t = a;</span><br><span class="line">    std::<span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">    t.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>()), t.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">rt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> &amp;self, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="type">int</span> p = ++tot;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[p].lc = <span class="built_in">self</span>(self, l, mid);</span><br><span class="line">        tr[p].rc = <span class="built_in">self</span>(self, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;;</span><br><span class="line">    rt[<span class="number">0</span>] = <span class="built_in">build</span>(build, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> insert = [&amp;](<span class="keyword">auto</span> &amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="type">int</span> q = ++tot;</span><br><span class="line">        tr[q] = tr[p];</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tr[q].cnt++;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">            tr[q].lc = <span class="built_in">self</span>(self, tr[p].lc, l, mid, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tr[q].rc = <span class="built_in">self</span>(self, tr[p].rc, mid + <span class="number">1</span>, r, x);</span><br><span class="line">        tr[q].cnt = tr[tr[q].lc].cnt + tr[tr[q].rc].cnt;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> p = std::ranges::<span class="built_in">lower_bound</span>(t, a[i]) - t.<span class="built_in">begin</span>();</span><br><span class="line">        rt[i + <span class="number">1</span>] = <span class="built_in">insert</span>(insert, rt[i], <span class="number">0</span>, n - <span class="number">1</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;](<span class="keyword">auto</span> &amp;self, <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="comment">// 线段树作差</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, t = tr[tr[q].lc].cnt - tr[tr[p].lc].cnt;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= k)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">self</span>(self, tr[p].lc, tr[q].lc, l, mid, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">self</span>(self, tr[p].rc, tr[q].rc, mid + <span class="number">1</span>, r, k - t);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        std::cout &lt;&lt; t[<span class="built_in">query</span>(query, rt[l - <span class="number">1</span>], rt[r], <span class="number">0</span>, n - <span class="number">1</span>, k)] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>暑假集训开始了，愉快的假期生活结束了＞︿＜<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/6164d4987d54bb804ebe4a2c1fa398af.jpeg" alt="wuwu"></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论与SG函数</title>
      <link href="/posts/59207/"/>
      <url>/posts/59207/</url>
      
        <content type="html"><![CDATA[<p>（本文章主要涉及Nim博弈及相关变种，二分图博弈以后再补_(:з)∠)_）</p><p>Nim博弈是最经典的博弈论问题之一，一般可以描述为如下：两个人轮流从若干堆石子中取石子，每次只能取一堆石子中的任意个，最后无法取（即所有石子都被取完）的玩家判负。Nim游戏拥有简洁的规则和优雅的结论，也是SG函数的基础。</p><h2 id="基本概念">基本概念</h2><p>首先明确一些概念，Nim博弈是公平组合游戏（Impartial Combinatorial Games, ICG）的一种，所谓公平组合游戏，需要满足以下几个条件</p><ul><li>有两个玩家</li><li>两个玩家轮流操作，在一个有限集合内任选一个进行操作，改变游戏当前局面</li><li>一个局面的合法操作只与游戏当前局面有关，与当前玩家和次序等其他因素无关（公平）</li><li>无法操作者判负</li></ul><p>为什么要提这个呢？因为从这些条件里，我们可以得出一个最基本的定理：一局游戏的胜负只与当前的局面有关，与当前是哪个玩家在操作无关，因为当局面确定，由于合法操作不受其他因素影响，那么其所有可以进行的操作与操作后的局面都是确定的，在两个玩家都绝对理性的情况下（这是大前提，否则就没有意义了），其胜负自然也是确定的。</p><p>那么，我们就可以把所有局面分成两种：必胜局面和必败局面。如果一个局面可以通过一步操作移动到一个必败局面，那么这就是一个必胜局面，否则就是一个必败局面。</p><h2 id="SG函数">SG函数</h2><p>有了上面的结论，我们就有了一种判断一个局面是否是必胜局面的办法：找出所有子局面，判断其中是否有必败局面。因为在取石子游戏中，操作之后问题规模一定会变小，也就相当于把当前问题划分为子问题。而对于足够小的子问题，我们可以很容易判断其胜负，如当石子数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>时显然是必败局面。<br>这显然是一个递归的问题，我们可以用记忆化搜索暴力解决，为了方便，我们假设只有两堆石子，且数量不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>]; <span class="comment">// -1表示未访问，0为必败，1为必胜。</span></span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (~dp[x][y])</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) <span class="comment">// 暴力枚举所有子局面</span></span><br><span class="line">        res |= !<span class="built_in">dfs</span>(x - i, y); <span class="comment">// 只要有一个局面为必败就是必胜局面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= y; ++i)</span><br><span class="line">        res |= !<span class="built_in">dfs</span>(x, y - i);</span><br><span class="line">    <span class="keyword">return</span> dp[x][y] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，当石子数或石子堆数过大时，上述方法都是不可行的，我们需要找到更本质的规律。</p><p>为了解决这个问题，我们引入SG函数。<br>一个局面的SG函数定义为其所有子局面的SG函数值的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">mex</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{mex}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mop"><span class="mord mathrm">mex</span></span></span></span></span>，即未出现过的最小整数。比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">mex</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\operatorname{mex}(0,1,2,4)=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">mex</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">mex</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\operatorname{mex}(1,2,3)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">mex</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，特别的，当一个局面没有子局面（石子数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）时，其SG函数值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>为什么要这么定义呢，不难发现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">mex</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{mex}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mop"><span class="mord mathrm">mex</span></span></span></span></span>函数有一个性质：如果一个局面的子局面包含SG值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>的局面，那么其SG值一定不为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，反之如果不包含SG值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>的子局面，其SG值一定为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。<br>然后，你就会发现这个东西好像似曾相识。仔细一想，这不就是我们之前定义必胜局面与必败局面的规则吗！把SG值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>的局面对应为必败局面，不为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>的局面定义为必胜局面，这两个规则不能说一模一样，只能说毫无差异。</p><p>有了上面的说明，我们就可以很容易的写出SG函数的打表代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> SG[<span class="number">100010</span>], vis[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">// 石子数为n的局面的SG值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 从小规模局面往大递推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123; <span class="comment">// 枚举所有子局面</span></span><br><span class="line">        vis[SG[i - j]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (vis[res] == i) <span class="comment">// 计算mex</span></span><br><span class="line">        ++res;</span><br><span class="line">    SG[i] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后当我们满怀期待地运行打表代码时，就会发现，对于这种不限石子数量的取法，其SG值与石子数是相等的……原因很明显，只要一堆石子不为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，先手就可以一次取完，也就是一个必胜局面。<br>好像走了条死路，让我们重新考虑两种局面之间的关系<s>其实只是因为我讲的顺序有点问题才导致这种尴尬的局面，但是写了这么多不想改了（</s></p><p>根据必胜局面与必败局面的定义，一个必败局面要么已经无法操作，要么所有子局面都是必胜局面，也就是后手面对的一定是一个必胜局面，那么后手为了取胜，一定会将游戏局面移向必败局面。如果我们可以找到必败局面的某个共同特点，并且这个特点满足：</p><ul><li>只要操作了就会被破坏（到达必胜局面）</li><li>只要被破坏就可以通过一次操作恢复（恢复必败局面）</li></ul><p>那么就可以简单地判断一个局面是否是必败局面——只要判断是否有这个特点。<br>为了方便，我就直接给出结论（主要是真不知道这个是怎么想出来的，太抽象了）——当所有石子数异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>时为必败局面，否则为必胜局面。</p><p>也就是说，异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>就是我们要找的那个共同特点。证明也很简单：</p><ul><li>当异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>时，不论先手怎么操作，都无法保持异或和不变，因为异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>说明二进制每一位上的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>都出现了偶数次，而一次只能改变一堆石子的数量，所以无法保持异或和不变。</li><li>当先手破坏这个特点时，由于只能让某一堆的石子变少，那么这堆石子的数量前后一定存在一个最高位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>不同，如将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span>，写成二进制<code>1100</code>，<code>1001</code>，第三位（从右往左）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>不同。并且由于之前异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，所以这一位上至少还存在着另一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，那么后手就可以通过操作这一堆石子，把先手破坏了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的个数奇偶性的位恢复为偶数，由于被破坏的位一定小于我们之前找的最高位，所以这样的恢复总是可以做到的。</li></ul><p>至此，我们就找到了解决Nim博弈的办法，只要求出每一堆石子的异或和，判断是否为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，现在看来，之前求的SG函数好像没有用，因为值等于石子堆数，要想看到SG函数发挥作用，需要分析另一种博弈——巴什博弈。</p><h2 id="巴什博弈">巴什博弈</h2><p>巴什博弈基本规则与Nim博弈相同，不同之处在于巴什博弈只有一堆石子，并且限制每次取的石子不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，也就是每次最少取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个，最多取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>个。<br>为了展示SG函数的作用，在这里我们先不分析，直接掏出之前的SG函数打表代码，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>时，打出来的SG函数如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 2, 3, 4, 0, 1, 2, 3, 4</span><br></pre></td></tr></table></figure><p>神奇的事情就发生了，SG函数的值出现了循环，循环节为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，根据SG函数的定义，当且仅当SG值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>时为必败局面，因此我们可以大胆猜测，当且仅当石子堆数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的倍数时，为必败局面，否则为必胜局面。</p><p>接下来分析为什么会这样，当石子个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的倍数时，假设先手取了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>个石子，那么后手就可以取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">m+1-a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>个石子，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\leq a \leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \leq m+1-a \leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，即后手的操作一定是合法的，这样一轮下来，石子的堆数减少了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，那么若干轮后石子堆数就会减为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，此时先手没有石子可取，判负。<br>而如果石子堆数不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的倍数，那么先手就可以取走<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \mod {m+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个石子从而让石子个数变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的倍数，因此是必胜局面。</p><p>这也说明了SG函数确实可以简单的表示局面的胜负，当游戏变得复杂时，比如限制取石子个数只能是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1, 2, 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span></span></span></span>或者别的什么限制，SG函数都能以一种通用的方式解决这些问题。</p><h2 id="多个游戏组合">多个游戏组合</h2><p>SG函数的作用不止如此。还记得我们对Nim游戏分析的结果吗，当且仅当所有堆的石子数异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>时为必败局面。其实并不是石子数的异或和，而是SG函数的异或和，只不过SG值与石子数相等而没有表现出来而已。</p><p>至于证明可以直接套用之前的分析，根据SG函数的定义，一个值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>的局面一定包含了SG值从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的所有子局面，当先手把局面向SG值较小的局面移动时，后手总是可以保持异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，而如果先手把局面向SG值较大的局面移动，后手就可以把那个局面再移回来，同样保持异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，游戏就会在保持异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>的情况下不断进行下去，一直到没有可以操作的游戏，则先手判负。</p><p>也就是说，当我们面对多个游戏且每个游戏都有不同的规则时，我们依然可以快速判断出胜者是谁，只需要分别计算每一个游戏的SG函数，然后计算异或和，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>时先手必败，否则先手必胜。</p><h2 id="总结">总结</h2><p>从上面的分析可以看出来，面对公平组合博弈论问题，打表求SG函数是通用的解法，但当数据范围过大时，依然是不可行的。这时有两种选择，一是对小范围数据进行打表，寻找规律，二是寻找必败态的共同特点。后者显然更具难度，但也是更涉及本质的做法。</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSGS算法</title>
      <link href="/posts/60907/"/>
      <url>/posts/60907/</url>
      
        <content type="html"><![CDATA[<p>BSGS算法（baby step giant step，大步小步算法），又叫北上广深算法（不是），是一种基于中间相遇思想求解离散对数的算法，即求解类似于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>x</mi></msup><mo>≡</mo><mi>b</mi><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^x\equiv b\pmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>的方程。</p><h2 id="BSGS算法">BSGS算法</h2><p>首先介绍最普通的BSGS算法。普通的BSGS算法要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>要互质，既然互质，那么根据欧拉定理</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^{\varphi(m)} \equiv 1\pmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.938em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p><p>也就是说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>x</mi></msup><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^x \pmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>为周期循环，那么如果方程有解，解一定在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>之间，如果暴力枚举，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>为质数时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>最大为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，最坏复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</p><p>普通的BSGS算法就是对上述暴力算法的一个优化，我们可以把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>改成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>t</mi><mo>−</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">At - B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，那么原式变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>A</mi><mi>t</mi><mo>−</mo><mi>B</mi></mrow></msup><mo>≡</mo><mi>b</mi><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^{At - B} \equiv b \pmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>互质，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>B</mi></msup></mrow><annotation encoding="application/x-tex">a^{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span></span>在模<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>意义下有逆元，所以可以把它移到右边，变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>A</mi><mi>t</mi></mrow></msup><mo>≡</mo><mi>b</mi><msup><mi>a</mi><mi>B</mi></msup></mrow><annotation encoding="application/x-tex">a^{At} \equiv ba^{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord mathnormal">b</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span></span>。然后我们可以预处理出右边的所有可能的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>对应的值，然后枚举左边的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，如果某个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>的值出现过，那么就可以得出解。</p><p>不难看出，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msqrt><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msqrt><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil\sqrt{\varphi(m)}\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.305em;"></span><span class="mopen">⌈</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span><span style="top:-2.895em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305em;"><span></span></span></span></span></span><span class="mclose">⌉</span></span></span></span>时，需要枚举的次数是最少的，但由于算欧拉函数本身就比较麻烦，一般直接取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msqrt><mi>m</mi></msqrt><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil\sqrt{m}\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">m</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mclose">⌉</span></span></span></span>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a, ll b, <span class="type">const</span> ll p)</span> <span class="comment">// 离散对数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1LL</span> % p == b % p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特判0</span></span><br><span class="line">    ll t = std::<span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">    std::map&lt;ll, ll&gt; mp;</span><br><span class="line">    ll d = <span class="number">1</span>; <span class="comment">// a^t</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        mp[b * d % p] = i; <span class="comment">// 可以直接覆盖，如果有重复的会取更大的，这样At - B就是最小的</span></span><br><span class="line">        d = d * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        a = a * d % p;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(a)) <span class="comment">// 存在</span></span><br><span class="line">            <span class="keyword">return</span> i * t - mp[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -INF; <span class="comment">// 无解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>可能会比较大，在传参之前记得取模（血的教训＞﹏＜）。</p><h2 id="扩展BSGS算法">扩展BSGS算法</h2><p>普通的BSGS算法要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>一定要互质，那如果不互质呢，一种很简单的想法是转换成互质的情况再用普通的BSGS算法求解，具体来说，我们可以从原式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>x</mi></msup><mo>≡</mo><mi>b</mi><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^x \equiv b \pmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>的左边提出一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>，变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⋅</mo><msup><mi>a</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mi>b</mi><mspace></mspace><mspace width="0.4444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \cdot a^{x-1} \equiv b \pmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，然后算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>gcd</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span></span></span></span>，然后等式两边和模数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>同时除以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>gcd</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span></span></span></span>，等式仍然成立，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>的公共质因子却变少了，一直重复这个过程，直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>互质，然后就可以用普通的BSGS算法解决了，假如这个过程进行了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>次，第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>次的最大公因数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，等式就变成了</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∏</mo><mi>i</mi><mi>k</mi></munderover><mfrac><mi>a</mi><msub><mi>g</mi><mi>i</mi></msub></mfrac><mo>⋅</mo><msup><mi>a</mi><mrow><mi>x</mi><mo>−</mo><mi>k</mi></mrow></msup><mo>≡</mo><mfrac><mi>b</mi><mrow><munderover><mo>∏</mo><mi>i</mi><mi>k</mi></munderover><msub><mi>g</mi><mi>i</mi></msub></mrow></mfrac><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mfrac><mi>m</mi><mrow><munderover><mo>∏</mo><mi>i</mi><mi>k</mi></munderover><msub><mi>g</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod\limits_i^k \frac{a}{g_i} \cdot a^{x-k} \equiv \frac{b}{\prod\limits_i^k g_i} \pmod {\frac{m}{\prod\limits_i^k g_i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1138em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8991em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.7752em;vertical-align:-2.4038em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.5361em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5361em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.7661em;"><span class="pstrut" style="height:3.5361em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.2131em;"><span class="pstrut" style="height:3.5361em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4038em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:3.5113em;vertical-align:-2.4038em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.5361em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5361em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.7661em;"><span class="pstrut" style="height:3.5361em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.2131em;"><span class="pstrut" style="height:3.5361em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4038em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p>这个时候因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>互质，我们可以用普通的BSGS算法解决，虽然相比与普通的BSGS左边多了一个系数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mi>i</mi><mi>k</mi></msubsup><mfrac><mi>a</mi><msub><mi>g</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\prod\limits_i^k \frac{a}{g_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5138em;vertical-align:-0.9777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5361em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，但对算法正确性没有影响，只要把原来的代码稍微改一下，最后的结果就是BSGS的返回值加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。<br>如果在迭代的过程中出现了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>不能被<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span></span></span></span>整除的情况，根据斐蜀定理，把原式转换成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msup><mi>a</mi><mo>−</mo><mi>y</mi><mi>m</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a^{x-1}a - ym = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，可得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>一定是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\gcd(a,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>的倍数，所以如果不是就说明原方程无解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a, ll b, <span class="type">const</span> ll p, ll k = <span class="number">1LL</span>)</span> <span class="comment">// k是多加的系数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k % p == b % p) <span class="comment">// 特判0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll t = std::<span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">    std::map&lt;ll, ll&gt; mp;</span><br><span class="line">    ll d = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        mp[b * d % p] = i;</span><br><span class="line">        d = d * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    a = k; <span class="comment">// 正常这里是1，加了系数所以是k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        a = a * d % p;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(a))</span><br><span class="line">            <span class="keyword">return</span> i * t - mp[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -INF; <span class="comment">// 无解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exBSGS</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll k = <span class="number">1</span>; <span class="comment">// k是系数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k % p == b % p) <span class="comment">// 迭代中特判0</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        ll gcd = std::<span class="built_in">gcd</span>(a, p);</span><br><span class="line">        <span class="keyword">if</span> (b % gcd)</span><br><span class="line">            <span class="keyword">return</span> -INF; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">if</span> (gcd == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSGS</span>(a, b, p, k) + i;</span><br><span class="line">        k = k * a / gcd % p, b /= gcd, p /= gcd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决头歌禁止复制粘贴</title>
      <link href="/posts/35276/"/>
      <url>/posts/35276/</url>
      
        <content type="html"><![CDATA[<p>相信被头歌的禁止复制粘贴恶心到了的人肯定不止我一个，这次写一个链表的题，每一关都要用到上一关的代码，每一关都要重新把4种构造函数和4个功能函数重新打一遍，只能说很符合我对头歌的印象😅😅😅。<br>于是本着偷懒顺便造福大众的想法，我开始寻找解决的办法。经过一天一夜的尝试与搜索，终于找到了一种解决办法：调用系统API模拟键盘输入。</p><h2 id="正文">正文</h2><p>如何调用系统API呢？如果是大佬当然有无数的方法，但我们作为小白，选择最简单的方法就好了，那就是我们无敌的Python（撒花）</p><p>首先，安装<code>PyWinHook</code>和<code>PyUserInput</code><br><code>PyWinHook</code>是Python的一个第三方库，可以对键盘、鼠标进行监听，<code>PyUserInput</code>可以模拟键盘鼠标输入。<br><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#pywinhook">https://www.lfd.uci.edu/~gohlke/pythonlibs/#pywinhook</a><br>在网址中找到对应的版本下载，如我的Python版本是<code>3.10.10 64bit</code>，那么就下载<code>pyWinhook‑1.6.2‑cp310‑cp310‑win_amd64.whl</code>，<code>cp310</code>表示<code>3.10</code>，<code>amd64</code>表示64位。<br>Python版本可以在命令行输入<code>python</code>查看，或者如果用的vscode可以直接在任意Python文件界面的右下角看到。</p><p>下载完毕后，打开文件夹，右键刚下载的文件，复制文件路径。然后在命令行中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install 路径</span><br><span class="line">pip install PyUserInput</span><br></pre></td></tr></table></figure><p>这样，我们就安装好了需要的第三方库，可以开始愉快地偷懒了ヾ(≧▽≦*)o<br>。<br>。<br>。</p><hr><p>本来应该是这样的……但实际用了之后，我才发现这玩意跑起来跟我想的根本不一样。因为遇到了一大障碍——代码补全。<br>本来方便敲代码地代码补全，在这个时候却起了反作用。由于编辑器自动补全括号，自动缩进，就导致原本正常的代码打出来之后就变得，嗯……一言难尽。只能说，作为一名程序员，在看到这样的代码时，本能地产生了一种恐惧。<br>然后，我想着只要先对字符串进行一下修改，比如把会自动补全的<code>&#125;</code>之类的去掉，删去部分回车和空格等。再然后，就陷入了长达一天的修改与尝试的循环（一天一夜里这个占了一天）……头歌的代码补全绝对是我见过的最魔幻的东西，我打一个<code>&#125;</code>它就再给我补一个，我不打<code>&#125;</code>它也不补，我打一个回车能变成两个回车，一个制表变成两个制表，零个制表还是零个制表……一天下来，我仿佛见证了生命进化的万千变化，整个人的精神都达到了新的高度~~（血压）~~。</p><p>那么说回正题，经过一天的尝试，最终找到了一种稍微正常的处理方法，能让打出来的代码没有那么抽象，以下是代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pykeyboard <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pymouse <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">m = PyMouse()  <span class="comment"># 建立鼠标对象</span></span><br><span class="line">k = PyKeyboard()  <span class="comment"># 建立键盘对象</span></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)  <span class="comment"># 延迟几秒以移动鼠标</span></span><br><span class="line"></span><br><span class="line">str_in = <span class="string">&#x27;&#x27;&#x27;#include &quot;ArrayList.h&quot;</span></span><br><span class="line"><span class="string">ArrayList::ArrayList()</span></span><br><span class="line"><span class="string">:data&#123;new int[1010]&#125;, capacity&#123;0&#125;, List(0)&#123;</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; size &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">ArrayList::ArrayList()</span></span><br><span class="line"><span class="string">:data&#123;new int[1010]&#125;, capacity&#123;0&#125;, List(0)&#123;</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; size &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">    for (int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line"><span class="string">        cout &lt;&lt; fuck;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># 粘贴代码，最好与示例格式一致</span></span><br><span class="line">str_in = str_in.replace(<span class="string">&#x27;  &#x27;</span>, <span class="string">&#x27;&#x27;</span>) </span><br><span class="line">str_in = str_in.replace(<span class="string">&#x27;\n&#125;&#x27;</span>, <span class="string">&#x27;&#125;\n&#x27;</span>) <span class="comment"># 玄学操作</span></span><br><span class="line">k.type_string(str_in)</span><br></pre></td></tr></table></figure><p>这样处理后，效果差不多是这样<img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/20231128221324.png" alt="res"><br>相信我，这已经是最正常的一个版本了，没有超出屏幕的缩进，没有多出来的空行，没有多出来的大括号，相比于其他版本，简直就是奈亚子与奈亚拉托提普相比。</p><p>当然，如果有人有足够的耐心、时间，也可以寻找一下更优的办法，找到了记得踢我一脚，反正我是不想尝试了……</p><h2 id="花絮">花絮</h2><p><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/20231128222233.png" alt="err">（失败尝试……）</p><hr><p>经过这次事件我才发现，头歌的格式化代码功能会把头文件引入的<code>#include</code>格式化到宏定义<code>#define</code>的后面，还会把<code>-&gt;</code>符号变成<code>- &gt;</code>导致编译错误……本来以为把<code>n</code>代码补全为<code>using namespace</code>已经够逆天了，没想到还有高手……</p>]]></content>
      
      
      <categories>
          
          <category> 实用？ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Splay树</title>
      <link href="/posts/19905/"/>
      <url>/posts/19905/</url>
      
        <content type="html"><![CDATA[<p>Splay树，即二叉伸展树，是一种非严格平衡的二叉搜索树，由丹尼尔·斯立特Daniel Sleator 和 罗伯特·恩卓·塔扬Robert Endre Tarjan 在1985年发明（摘自百度百科）。相比与AVL、红黑树而言，Splay树不需要额外地存储平衡信息，因此显得更为简洁，代码实现也较为简单（指150行代码），同时具有很强的扩展性，常用于算法竞赛中。</p><p>至于我为什么突然想要学Splay树，因为这是Tarjan发明的……没错，就是求强连通分量、割点、桥的Tarjan算法的那个Tarjan。事情的起因是我最近刚学完强连通分量，然后查了一下Tarjan的资料，发现原来是祖师爷级别的大佬，拿过图灵奖，发明了很多图论的重要算法和数据结构。于是就对Splay树产生了兴趣，虽然这玩意已经明显超过了我的算法水平（刚学完强连通的蒟蒻），但我还是<s>自不量力</s>毅然决然地花了两天手搓了Splay，然后又花了一天的时间调试。<br>那么废话了那么多，接下来正式介绍Splay树</p><p>（以下内容和代码部分<s>抄袭</s>参考自<a href="https://oi-wiki.org/ds/splay/">oiwiki</a>和其他人的博客、文章等）<br>（图片均使用开源网站<a href="https://www.iodraw.com/">ioDraw</a>绘制，感谢开源者的贡献）</p><hr><h2 id="基本成员">基本成员</h2><p>Splay树需要存储的主要信息如下：</p><ul><li><code>rt</code>——根节点，<code>ch[][2]</code>——左右子节点，<code>fa[]</code>——父节点；</li><li><code>cnt[]</code>——每个节点有几个相同的值，<code>sz[]</code>——每个节点子树的大小，<code>v[]</code>——节点的值；</li></ul><p>然后就是变量<code>tot</code>为新插入的节点分配地址。</p><h2 id="基本函数">基本函数</h2><p>首先是Splay树的几个基本函数：</p><ul><li><code>get()</code>判断一个节点是父节点的左节点还是右节点；</li><li><code>clear()</code>清除一个节点的相关数据；</li><li><code>update()//网上一般叫maintain，但我用这个用习惯了……</code>更新（维护）一个节点的相关信息（子树大小等）；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == ch[fa[x]][<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; v[x] = cnt[x] = fa[x] = ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = sz[x] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; sz[x] = sz[ch[x][<span class="number">0</span>]] + sz[ch[x][<span class="number">1</span>]] + cnt[x]; &#125;</span><br></pre></td></tr></table></figure><p><s>然后就是Splay树最主要的操作、本文的主角——<code>splay</code>：</s><br>在介绍splay操作之前，我们还需要一点前置知识。</p><p>我们知道，普通的二叉搜索树容易退化成链导致效率变低，所以需要调整。但调整的同时又不能改变二叉搜索树的性质，因此显然不能直接去交换。我们需要一种新的操作——旋转。<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/rotate.png" alt="旋转">旋转就是把一边过多的节点往另一边“匀一下”，让整棵树更平衡。因为对搜索树来说，根节点的左子树都小于根节点，右子树都大于根节点，如果我们想要让两边的节点数更平衡的话，那就只能让根节点“易位”，换一个数来当根节点。所以旋转的本质就是改变根节点（个人认为§(<em>￣▽￣</em>)§）。同时旋转也不能改变搜索树的性质，因此两边的树的中序遍历都是1 2 3 4 5。</p><p>那么旋转操作具体要如何实现呢？让我们换一张图片来更好地说明。<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/rotate1.png" alt="旋转">我们的目标是把x节点旋转到y节点，其他节点都不是必须的，因此用虚线表示。<br>首先看看哪些节点的父节点发生了改变，首先y的父亲变成了x，然后3的父亲变成了y，但要注意的是，3节点不是必须的，也就是说，实际旋转的时候3节点可能不存在，因此需要先判定一下，然后就是x的父亲变成了z，这里z虽然也可能不存在，但如果z不存在那么z就是0，x是根节点，根节点的父亲是0这很合理，所以不需要判定。<br>接下来再来看看子节点的变化，子节点的变化和父节点的变化是相对应的，x的右孩子变成y，y的左孩子变成3，如果3不存在则设为0，然后z的左孩子变成x，注意判定z是否存在。<br>总结来说，在一次旋转操作中，我们要改变6个指针的指向，3个指向父亲的，3个指向孩子的，最后别忘了更新相应节点，具体代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cip = <span class="built_in">get</span>(x), y = fa[x], z = fa[y];</span><br><span class="line">    fa[x] = z, fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (ch[x][cip ^ <span class="number">1</span>])</span><br><span class="line">        fa[ch[x][cip ^ <span class="number">1</span>]] = y; <span class="comment">// 改变父亲</span></span><br><span class="line">    ch[y][cip] = ch[x][cip ^ <span class="number">1</span>];</span><br><span class="line">    ch[x][cip ^ <span class="number">1</span>] = y;</span><br><span class="line">    <span class="keyword">if</span> (z)</span><br><span class="line">        ch[z][y == ch[z][<span class="number">1</span>]] = x; <span class="comment">// 改变孩子</span></span><br><span class="line">    <span class="built_in">update</span>(y), <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说完了旋转，接下来就真的正式进入到Splay树最重要的操作——<code>splay</code>。</p><p>所谓<code>splay</code>操作，就是把一个节点通过旋转移动至根节点。Splay树规定，每次访问一个节点（插入、查询等），就必须将其旋转至根节点，这涉及到Splay树的核心思想——刚被访问的节点之后仍可能被访问，因此应该让它更靠近根节点。</p><p>那么具体要如何实现呢？根据父节点是否是根节点，以及与父节点和父节点的父节点是否在同一边，分为三种情况：</p><ul><li><p>父节点是根节点；</p></li><li><p>父节点不是根节点：</p><ul><li>子节点是父节点的左（右）孩子，同时父节点也是左（右）孩子；</li><li>子节点是父节点的左（右）孩子，但父节点是右（左）孩子；</li></ul></li></ul><p>文字的描述可能不是很直观，直接来看图片。</p><p>首先是第一种情况：<img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/splay1.png" alt="splay">这种最简单，直接旋转一次x即可。<br>接下来是第二种情况：<img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/splay2.png" alt="splay">对于x与y处于同侧的情况，需要先旋转父节点y，再旋转x。<br>最后是第三种情况：<img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/splay3.png" alt="splay"><br>这种情况下，旋转两次x节点即可。</p><p>虽然听起来好像很麻烦，但其实代码很短：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> f = fa[x]; f = fa[x], f; <span class="built_in">rotate</span>(x))</span><br><span class="line">        <span class="keyword">if</span> (fa[f]) <span class="comment">// 父节点为根节点只用旋转一次</span></span><br><span class="line">            <span class="built_in">rotate</span>(<span class="built_in">get</span>(x) == <span class="built_in">get</span>(f) ? f : x);</span><br><span class="line">    rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也许有人注意到了，之前不是说旋转操作可以把节点移动至根节点吗？那么为什么不直接一直旋转x节点呢？</p><p>这就涉及到单旋与双旋的区别，具体可以去知乎看一下这个问题<a href="https://www.zhihu.com/question/40777845">Splay 中的旋转操作用单旋与双旋的区别是什么？</a>简单来说，就是双旋可以用势能分析的方法证明其均摊复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，而单旋会被卡成链。至于势能分析怎么分析的，等我哪天有时间了也许会学一下（咕咕咕(/▽＼)）。</p><h2 id="基本功能">基本功能</h2><p>在上面介绍的几个函数的帮助下，我们的Splay树终于可以成为一个真正的平衡树，去完成平衡树应有的操作了。<br>&lt;(￣︶￣)↗[GO!]</p><h3 id="插入">插入</h3><p>第一个功能当然就是插入了，不能插入就始终是一棵空树，更不用说后面的操作了。<br>对于插入操作，首先要判断树是否为空，如果为空就直接插入根节点。否则就按照搜索树的性质往下查找，如果找到了相应节点，就把节点的计数加1，如果找不到则创建一个新节点。记得更新：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) &#123; <span class="comment">// 根节点为空</span></span><br><span class="line">        v[++tot] = x, cnt[tot]++;</span><br><span class="line">        rt = tot, <span class="built_in">update</span>(tot);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = rt, f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[p] == x) &#123; <span class="comment">// 存在对应节点</span></span><br><span class="line">            cnt[p]++;</span><br><span class="line">            <span class="built_in">update</span>(p), <span class="built_in">update</span>(f);</span><br><span class="line">            <span class="built_in">splay</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f = p, p = ch[p][x &gt; v[p]];</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123; <span class="comment">// 不存在对应节点</span></span><br><span class="line">            v[++tot] = x, cnt[tot]++;</span><br><span class="line">            ch[f][x &gt; v[f]] = tot;</span><br><span class="line">            fa[tot] = f;</span><br><span class="line">            <span class="built_in">update</span>(tot), <span class="built_in">update</span>(f);</span><br><span class="line">            <span class="built_in">splay</span>(tot);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询排名">查询排名</h3><p>既然叫搜索树，那么当然有搜索的功能。如果要查询一个数<code>x</code>的排名，我们还是按照搜索树的性质向下查找。首先判断是否小于当前节点，如果小于直接搜索左子树，否则就让<code>ans</code>加上左子树的大小（之前记录的子树大小在这里排上用场了），因为我们已经可以确定左子树全部小于<code>x</code>，然后再判断是否等于当前节点，不等于则让<code>ans</code>加上当前节点的<code>cnt</code>值，然后搜索右子树，当找到的时候返回<code>ans + 1</code>，最后记得<code>splay</code>，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">srank</span><span class="params">(T x)</span> <span class="comment">// 查询x的排名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, p = rt;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; v[p])</span><br><span class="line">            p = ch[p][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= v[p]) &#123;</span><br><span class="line">            ans += sz[ch[p][<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">if</span> (x == v[p]) &#123;</span><br><span class="line">                <span class="built_in">splay</span>(p);</span><br><span class="line">                <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cnt[p];</span><br><span class="line">            p = ch[p][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询第k个数">查询第k个数</h3><p>查询第k个数和查询排名的过程差不多，只是反过来而已。<br>首先还是先判断左子树，只不过这次是判断k是否大于左子树的大小，小于则搜索左子树，否则就让<code>k -= sz[ch[p][0]] + cnt[p]</code>，即减去左子树的大小和当前节点的计数，然后判断k减完之后是否小于等于0，如果是则说明当前节点就是排名为k的数，否则就搜索右子树，最后记得<code>splay</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">// 查询第k个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = rt;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; sz[ch[p][<span class="number">0</span>]]) &#123;</span><br><span class="line">            k -= sz[ch[p][<span class="number">0</span>]] + cnt[p];</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">splay</span>(p);</span><br><span class="line">                <span class="keyword">return</span> v[p];</span><br><span class="line">            &#125;</span><br><span class="line">            p = ch[p][<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            p = ch[p][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T&#123;&#125;; <span class="comment">// 我也不知道能返回什么，就随便写了一个(～￣▽￣)～</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两棵树">合并两棵树</h3><p>严格来说，这并不算Splay树的功能。因为对合并的两棵树有严格的要求（一棵树的最大值小于另一棵树的最小值），同时由于我们是用的数组模拟而不是指针，所以基本没有可操作性。这个操作仅仅是为了在删除一个节点之后合并左右子树的而已，而非真的合并两颗任意的Splay，但为了方便理解我还是把它单独写了一个函数。<br>至于合并的具体步骤，首先判断是否有子树为空，有则直接让根节点等于非空的那颗树，否则就先找到左子树的最大值，然后将其旋转至根节点，然后将右子树的根节点的父亲设为我们刚旋转上来的节点就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">// 合并两棵树，要求x的最大值小于y的最小值，用于删除操作中合并左右两颗子树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) &#123;</span><br><span class="line">        rt = (x ? x : y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = x;</span><br><span class="line">    <span class="keyword">while</span> (ch[p][<span class="number">1</span>])</span><br><span class="line">        p = ch[p][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">splay</span>(p); <span class="comment">// 将x的最大值旋转至根节点</span></span><br><span class="line">    ch[p][<span class="number">1</span>] = y;</span><br><span class="line">    fa[y] = p;</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除指定节点">删除指定节点</h3><p>要删除一个节点，首先需要将其旋转至根节点。然后看<code>cnt</code>是否大于1，如果大于则说明有多个相同值，只要把<code>cnt</code>减1即可，否则就用上面的函数合并左右子树，然后清除对应节点，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(T x)</span> <span class="comment">// 删除值为x的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srank</span>(x); <span class="comment">// 找到x并旋转至根节点</span></span><br><span class="line">    <span class="keyword">if</span> (cnt[rt] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cnt[rt]--;</span><br><span class="line">        <span class="built_in">update</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ch[rt][<span class="number">0</span>] || !ch[rt][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = rt;</span><br><span class="line">        rt = ch[rt][!ch[rt][<span class="number">0</span>]];</span><br><span class="line">        fa[rt] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">clear</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = rt;</span><br><span class="line">    <span class="built_in">merge</span>(ch[rt][<span class="number">0</span>], ch[rt][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">clear</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找前驱、后继">查找前驱、后继</h3><p>x的前驱的定义是小于x的最大的数，后继则是反过来，指大于x的最小的数。直接求似乎有点麻烦，我们可以换一个思路。<br>后继与前驱类似，我们以前驱来作为例子。首先插入x，插入之后x被自动移动至根节点，那么这时x的左子树全部小于x，x的前驱就是左子树中最大的数，找到这个数返回，然后删除x节点即可。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">pre_nxt</span><span class="params">(<span class="type">int</span> x, <span class="type">bool</span> op)</span> <span class="comment">// 前驱、后继</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="type">int</span> p = ch[rt][op];</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> T&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (ch[p][!op])</span><br><span class="line">        p = ch[p][!op];</span><br><span class="line">    <span class="built_in">del</span>(x);</span><br><span class="line">    <span class="keyword">return</span> v[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>至此，Splay树的基本功能就介绍完毕了ヾ(≧▽≦*)o。以下是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Splay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> tot, rt;</span><br><span class="line">    std::vector&lt;T&gt; v;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; fa, cnt, sz;</span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 2&gt;&gt; ch;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == ch[fa[x]][<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; sz[x] = sz[ch[x][<span class="number">0</span>]] + sz[ch[x][<span class="number">1</span>]] + cnt[x]; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; v[x] = cnt[x] = fa[x] = ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = sz[x] = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 旋转</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> cip = <span class="built_in">get</span>(x), y = fa[x], z = fa[y];</span><br><span class="line">        fa[x] = z, fa[y] = x;</span><br><span class="line">        <span class="keyword">if</span> (ch[x][cip ^ <span class="number">1</span>])</span><br><span class="line">            fa[ch[x][cip ^ <span class="number">1</span>]] = y; <span class="comment">// 改变父亲</span></span><br><span class="line">        ch[y][cip] = ch[x][cip ^ <span class="number">1</span>];</span><br><span class="line">        ch[x][cip ^ <span class="number">1</span>] = y;</span><br><span class="line">        <span class="keyword">if</span> (z)</span><br><span class="line">            ch[z][y == ch[z][<span class="number">1</span>]] = x; <span class="comment">// 改变孩子</span></span><br><span class="line">        <span class="built_in">update</span>(y), <span class="built_in">update</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> f = fa[x]; f = fa[x], f; <span class="built_in">rotate</span>(x))</span><br><span class="line">            <span class="keyword">if</span> (fa[f]) <span class="comment">// 父节点为根节点只用旋转一次</span></span><br><span class="line">                <span class="built_in">rotate</span>(<span class="built_in">get</span>(x) == <span class="built_in">get</span>(f) ? f : x);</span><br><span class="line">        rt = x;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">// 合并两棵树，要求x的最大值小于y的最小值，用于删除操作中合并左右两颗子树</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) &#123;</span><br><span class="line">            rt = (x ? x : y);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p = x;</span><br><span class="line">        <span class="keyword">while</span> (ch[p][<span class="number">1</span>])</span><br><span class="line">            p = ch[p][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">splay</span>(p); <span class="comment">// 将x的最大值旋转至根节点</span></span><br><span class="line">        ch[p][<span class="number">1</span>] = y;</span><br><span class="line">        fa[y] = p;</span><br><span class="line">        <span class="built_in">update</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Splay</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">        : rt&#123;<span class="number">0</span>&#125;, tot&#123;<span class="number">0</span>&#125;, <span class="built_in">ch</span>(x + <span class="number">10</span>), <span class="built_in">fa</span>(x + <span class="number">10</span>), <span class="built_in">v</span>(x + <span class="number">10</span>), <span class="built_in">cnt</span>(x + <span class="number">10</span>), <span class="built_in">sz</span>(x + <span class="number">10</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Splay</span>() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) &#123; <span class="comment">// 根节点为空</span></span><br><span class="line">            v[++tot] = x, cnt[tot]++;</span><br><span class="line">            rt = tot, <span class="built_in">update</span>(tot);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p = rt, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[p] == x) &#123; <span class="comment">// 存在对应节点</span></span><br><span class="line">                cnt[p]++;</span><br><span class="line">                <span class="built_in">update</span>(p), <span class="built_in">update</span>(f);</span><br><span class="line">                <span class="built_in">splay</span>(p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f = p, p = ch[p][x &gt; v[p]];</span><br><span class="line">            <span class="keyword">if</span> (!p) &#123; <span class="comment">// 不存在对应节点</span></span><br><span class="line">                v[++tot] = x, cnt[tot]++;</span><br><span class="line">                ch[f][x &gt; v[f]] = tot;</span><br><span class="line">                fa[tot] = f;</span><br><span class="line">                <span class="built_in">update</span>(tot), <span class="built_in">update</span>(f);</span><br><span class="line">                <span class="built_in">splay</span>(tot);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">srank</span><span class="params">(T x)</span> <span class="comment">// 查询x的排名</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, p = rt;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; v[p])</span><br><span class="line">                p = ch[p][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= v[p]) &#123;</span><br><span class="line">                ans += sz[ch[p][<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">if</span> (x == v[p]) &#123;</span><br><span class="line">                    <span class="built_in">splay</span>(p);</span><br><span class="line">                    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += cnt[p];</span><br><span class="line">                p = ch[p][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">// 查询第k个数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = rt;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; sz[ch[p][<span class="number">0</span>]]) &#123;</span><br><span class="line">                k -= sz[ch[p][<span class="number">0</span>]] + cnt[p];</span><br><span class="line">                <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">splay</span>(p);</span><br><span class="line">                    <span class="keyword">return</span> v[p];</span><br><span class="line">                &#125;</span><br><span class="line">                p = ch[p][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                p = ch[p][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(T x)</span> <span class="comment">// 删除值为x的节点</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">srank</span>(x); <span class="comment">// 找到x并旋转至根节点</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[rt] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt[rt]--;</span><br><span class="line">            <span class="built_in">update</span>(rt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ch[rt][<span class="number">0</span>] || !ch[rt][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = rt;</span><br><span class="line">            rt = ch[rt][!ch[rt][<span class="number">0</span>]];</span><br><span class="line">            fa[rt] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clear</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp = rt;</span><br><span class="line">        <span class="built_in">merge</span>(ch[rt][<span class="number">0</span>], ch[rt][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">clear</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pre_nxt</span><span class="params">(T x, <span class="type">bool</span> op)</span> <span class="comment">// 前驱、后继</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="type">int</span> p = ch[rt][op];</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="keyword">return</span> T&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (ch[p][!op])</span><br><span class="line">            p = ch[p][!op];</span><br><span class="line">        <span class="built_in">del</span>(x);</span><br><span class="line">        <span class="keyword">return</span> v[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（这段代码能过洛谷的模板题，应该是没什么大问题吧……）</p><p>总的来说，Splay树作为Tarjan大神提出来的数据结构，还是非常有学习的价值的。维持平衡的操作只有一个<code>splay</code>而已，而且也不需要分那么多种情况，其他的函数都可以视情况进行修改和删除，扩展性非常强。</p><hr><p>闲聊：</p><p>想给芙宁娜一个完整的家（<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/fufu.jpg" alt="辛苦你了"></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 入门 </tag>
            
            <tag> Splay树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 901 C</title>
      <link href="/posts/13293/"/>
      <url>/posts/13293/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1875/problem/C">原题链接</a></p><hr><p>这题的思路其实很简单，就是直接贪心加暴力即可。有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个苹果和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>个人，要想平均分配同时使切苹果的次数最少，那么就只需要切多出来的那部分就行了，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">n \bmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，其他的既然已经能够平均分配，切了之后也依然能平均分配，没必要画蛇添足地去切。所以只需要一个while循环就能解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = n % m;</span><br><span class="line"><span class="keyword">while</span> (a) &#123;</span><br><span class="line">    ans += a;</span><br><span class="line">    a = a * <span class="number">2</span> % m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果直接这样写的话，就会发现样例都过不了。因为有些情况是无论怎么切都无法平均分配的，上述代码遇到这种情况显然会直接死循环，所以这题的关键就在于如何判断能否平均分配。</p><p>首先，假如某种情况下可以均分，比如每个人分到了1.5个苹果，那么我们就可以把那些重量为1的苹果都切成0.5，也就是切成最小的，同时苹果依然可以均分。这么做的意义在于，当我们把所有苹果都切成最小的那种时，其实就相当于在每一次切苹果时都是直接切所有苹果，也就是直接让苹果的数量翻倍。也就是说，可以均分和这个式子等价（具体的充分必要性我就不证了，<s>绝不是不会</s>）：<br>\[n \times 2^k \bmod m = 0\]（或者反过来考虑，即全部切成碎块之后再把每个人分到的碎块合起来）在数据范围内，即使考虑最差情况，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>也不会超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span>，如果能均分的话，最多乘上31次2，也就是循环31次，时间肯定够。所以我们只需要先判断一下能否均分，如果可以就直接暴力模拟，就能过这题。</p><p>至于如何判断能否整除，可以从质因数分解的角度考虑。每次乘2就是往<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>上加一个质因子2，也就是说如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi mathvariant="normal">/</mi><mi>gcd</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m / \gcd(n,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>不是2的次幂，也就是含有2以外的质因子，那么我们无论如何往<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>上加2都无法1整除<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a = n % m;</span><br><span class="line">        <span class="type">int</span> gcd = __gcd(a, m);</span><br><span class="line">        <span class="keyword">if</span> (m / gcd - <span class="built_in">lowbit</span>(m / gcd) &amp;&amp; a != <span class="number">0</span>)</span><br><span class="line">            ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span> (a) &#123;</span><br><span class="line">                ans += a;</span><br><span class="line">                a = a * <span class="number">2</span> % m;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/112113626_p1.png" alt="fufu"></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing 95</title>
      <link href="/posts/24657/"/>
      <url>/posts/24657/</url>
      
        <content type="html"><![CDATA[<p>原题链接——<a href="https://www.acwing.com/problem/content/description/97/">Acwing95</a><br>解法来源《算法竞赛进阶指南》</p><hr><p>想清楚之后并不是很难的题，但个人认为这是对思维提升非常大的一道题，刷新了我对递推和枚举的认识，故记录一下。</p><p>首先注意这一题的数据量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">n \leq 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">500</span></span></span></span>，数据量较小，同时矩阵也只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5 \times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，那么我们可以考虑遍历状态空间，然后取最小值。<br>问题在于如何遍历，如果直接枚举所有选择，那么就有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>6</mn></msubsup><msubsup><mi>C</mi><mn>25</mn><mi>i</mi></msubsup><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{6}{C_{25}^{i}} \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2537em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-2.4519em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">25</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>种情况，大约是1e8种，大概率会T<s>也许放牛客上能过</s>。</p><p>那么接下来让我们回到题目本身，题目的目的是把所有灯都打开。假如我们已经枚举了第一排的可能的操作，但第一排仍有未打开的灯，那么显然只能通过开关相应的第二排的开关来把第一排还未打开的灯打开，同时第二排其他的开关又不能动，因为会破坏第一排本来已经打开的灯的状态，也就是说，第二排的开关操作是固定的，同理，如果第二排操作完后仍有灯关着，那么只能通过操作第三排的相应开关来打开……以此类推，如果在操作完最后一排后最后一排仍有灯关着或者操作步数大于6，那么就说明无法在6步以内将灯全部打开。所以，我们其实只需要枚举第一排的操作，就可以遍历所有可能的操作（这里的可能指的是可能将灯全部打开的操作，而非所有可以选择的操作）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acwing 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, string a[])</span>  <span class="comment">// 反转函数（上面的灯不反转不影响结果，可以偷下懒）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt; <span class="number">4</span> || yy &lt; <span class="number">0</span> || yy &gt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        a[yy][xx] ^= <span class="number">1</span>; <span class="comment">//&#x27;0&#x27; = 48</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> cnt)</span> <span class="comment">// 判断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string tmp[<span class="number">5</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>]&#125;; <span class="comment">// 备份</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++cnt &gt; <span class="number">6</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="built_in">rev</span>(j, i + <span class="number">1</span>, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (tmp[<span class="number">4</span>][i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> cnt)</span>  <span class="comment">// 枚举第一行的操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(now + <span class="number">1</span>, cnt);  <span class="comment">// now不反转</span></span><br><span class="line">        <span class="built_in">rev</span>(now, <span class="number">0</span>, a);</span><br><span class="line">        <span class="built_in">dfs</span>(now + <span class="number">1</span>, cnt + <span class="number">1</span>);  <span class="comment">// now反转</span></span><br><span class="line">        <span class="built_in">rev</span>(now, <span class="number">0</span>, a);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">check</span>(cnt);</span><br><span class="line">        <span class="built_in">rev</span>(now, <span class="number">0</span>, a);</span><br><span class="line">        <span class="built_in">check</span>(cnt + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">rev</span>(now, <span class="number">0</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        ans = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">6</span>)</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种解法最让人迷惑的点大概就是枚举第一排操作为什么有时候要把本来已经打开的灯关掉（我想了好久才懂），要注意的是，我们是在遍历可能的状态空间，而非直接去找最小的操作步数，相比与去分析输入的矩阵寻找答案，这种枚举的思想也许更适合计算机。</p><hr><p><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/1694003151402.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组总结</title>
      <link href="/posts/54312/"/>
      <url>/posts/54312/</url>
      
        <content type="html"><![CDATA[<p>最近花了两天时间学了下树状数组，然后感觉堪比玄学，故写篇文章总结一下。<br>2024.08.07 UPD：添加了树状数组的树形结构解释，与树状数组上二分。</p><hr><p>树状数组（<em>binary indexed tree</em>），也叫BIT，又以其发明人名字被称为Fenwick树。树状数组利用二进制下标来维护区间和，能够做到以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span></span>的复杂度进行单点修改和区间求和，同时配合差分数组等结构，还能做到区间修改、单点查询和区间修改、区间查询等功能，相比与线段树来说更为简单和优雅。</p><h2 id="基本知识">基本知识</h2><p>树状数组最为重要的一个设定就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lowbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span>——二进制最低位的1及其后面的0所组成的数字，相比与前缀和，树状数组的每一位维护的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi>i</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>i</mi><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(i-lowbit(i),i\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>的区间和，比如6，二进制为<code>110</code>，那么这一位维护的就是原数组6到4<code>100</code>的区间和（不包含4）。</p><p>那么要如何计算一个数的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lowbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span>呢？如果用一个1作为check来判断每一位是否是1，那么代码大概长这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= __lg(x); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &amp; (<span class="number">1ll</span> &lt;&lt; i))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1ll</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，不但运行速度慢，而且也不够简洁优雅，不符合树状数组的特性<s>不是</s>，所以我们需要一种更为简单的方法。因此，就有了下面这个公式\[lowbit(x)=x&amp;-x\]为什么会这样呢？我们知道，在计算机中，负数采用补码形式存储，而补码就是<strong>取反加1</strong>，也就是将最低位1之后的所有位全部取反。所以只需要用这个简单的公式就能轻松地得到一个数的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lowbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span>。</p><h2 id="基本操作">基本操作</h2><p>最简单的树状数组支持两种操作：<strong>单点修改</strong>和<strong>区间查询</strong>。两种操作都能够以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span></span>级别的复杂度和5行以内的代码实现，十分方便。</p><p>首先来看修改操作。如果是普通的数组，那么我们只需要直接修改对应位置的数字就行了。但树状数组的每一位维护的是区间和，那么很显然我们在修改时应该把所有包含该位置的区间都更新一遍。那么哪些区间会包含需要修改的位置呢？假设需要修改的位置为<em>i</em>，那么一个树状数组所维护的区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi>j</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>j</mi><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(j-lowbit(j),j\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>想要包含<em>i</em>就需要保证<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j-lowbit(j)&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&gt;</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j&gt;=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，要直接找出这样的区间似乎有点抽象，我们先来举个简单的例子。</p><p>假设现在要修改的的位置<em>i</em>为<code>1001 0110</code>（150），让我们从<code>1001 0111</code>开始枚举，显然这个数不满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j-lowbit(j)&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，排除。继续往后找，下一个数是<code>1001 1000</code>,减去<em>lowbit</em>为<code>1001 0000</code>,显然满足要求，那么我们需要修改的第一个元素就找到了——<code>1001 1000</code>。继续往下找，显然<code>1001 1000</code>无论后面的3个0那个变成1都不满足条件（<code>1001 1000</code>本身就大于<em>i</em>，后面加1后再减去<em>lowbit</em>一定大于<em>i</em>）。那么再继续往后找，也就是<code>1010 0000</code>，显然满足，同时我们也可以发现后面无论如何添1都不满足……以此类推，假设数组长度是<code>1111 1111</code>，那么我们需要修改的元素下标如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001</span> <span class="number">0110</span> <span class="comment">//自己显然可以，上面忘记写了……</span></span><br><span class="line"><span class="number">1001</span> <span class="number">1000</span></span><br><span class="line"><span class="number">1010</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1100</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure><p>发现规律了吗，整个下标变化的过程就是一个进位的过程，每次加的都是<em>lowbit</em>，直到到达数组边界。（应该有更为形象的理解方式，但我想不到……看别人写的也不能理解，就贴个链接吧……<a href="https://zhuanlan.zhihu.com/p/93795692">算法学习笔记(2) : 树状数组</a>)<br>回到正题，既然知道了怎么找区间，那么代码就好写了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span> </span>&#123; <span class="comment">//i为位置，x为改变的量</span></span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= nmax; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        tree[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于修改，求和就要简单很多。只需要利用树状数组维护的是区间和这一特性，把要求和的区间下标以二进制展开就行了。比如我们要求<code>1001 0110</code>的前缀和，那么我们只需要把它拆成以下几个区间：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1001 0110 --- 1001 0100</span><br><span class="line">1001 0100 --- 1001 0000</span><br><span class="line">1001 0000 --- 1000 0000</span><br><span class="line">1000 0000 --- 0000 0000</span><br></pre></td></tr></table></figure><p>每次拆区间就是减去<em>lowbit</em>，同时要注意到，由于树状数组维护的区间是左开右闭的，所以任何区间都无法包含0，也就是说，树状数组的下标必须从1开始<s>当然要是不嫌麻烦可以每次求和都单独把0加上</s>求和代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        res += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要求区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的和只需要用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sum(r)-sum(l-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>就行了。</p><p>那么，至此树状数组的基本操作就介绍完了。</p><h2 id="UPD：树状数组的树形结构">UPD：树状数组的树形结构</h2><p>在经过了一年不眠不休的思考后（，我终于理解了树状数组的树到底是什么样的，对于各种操作的理解在结合了树的结构之后就会变得非常自然。</p><p>树状数组之所以被称为线段树青春版，是因为其结构确实跟线段树差不多，回想一下线段树的结构，每次都是将区间左右均分为左儿子和右儿子，树状数组其实也是类似的，只不过多了一些限制条件而已，具体来说，每段区间的长度都是2的次幂，比如1，2，4，8等，这是由树状数组的性质决定的，因为每个节点维护的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(x-lowbit(x),x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span>区间，其长度也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，所以一个树状数组的结构大概长这样<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/fenwick1.jpg" alt="fenwick1"><br>当然如果真长这样的话树状数组的空间就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>，而不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>了，跟线段树也就没区别了，因此，树状数组做了一个优化，对于每个节点的左右儿子，只存储左儿子，优化后的树状数组长这样<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/blog/fenwick2.jpg" alt="fenwick2"><br>再标上节点对应的下标后，是不是感觉一下就熟悉了起来。这样还有一个好处，那就是任一节点的下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>——也就是所存储的区间长度，或者说那不存在的右边的兄弟的长度，就正好是父节点的下标，这就是为什么在更新时是不断加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，因为这样就可以不断的找到父节点，从而更新整棵树，这有点类似与zkw线段树的自底向上的更新方式。</p><h2 id="例题及扩展功能">例题及扩展功能</h2><h3 id="单点修改，区间查询">单点修改，区间查询</h3><p>首先是洛谷上的两道模板题：<br><a href="https://www.luogu.com.cn/problem/P3374">P3374</a><br>这就是最简单的树状数组，单点修改，区间查询，多次询问，直接上模板就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        tree[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; r &gt; <span class="number">0</span>; r -= <span class="built_in">lowbit</span>(r))</span><br><span class="line">        res += tree[r];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="built_in">update</span>(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">update</span>(y, x, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">sum</span>(y) - <span class="built_in">sum</span>(x - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（突然发现忘记说怎么初始化树状数组了，只需要在输入的时候<em>update</em>每一位就行了，可以理解为初始有一个所有项都为0的数组，每次输入都相当于是单点修改）</p><hr><h3 id="区间修改，单点查询">区间修改，单点查询</h3><p>另一道模板题是<a href="https://www.luogu.com.cn/problem/P3368">P3368</a></p><p>这题就涉及到了树状数组的另一个用法，区间修改，单点查询。这乍一看跟树状数组的基本操作不能说没有关系，只能说是南辕北辙。那么这个时候就需要另一种数据结构了——差分数组。</p><p>在差分数组里，对区间的修改只需要修改区间两头的数字，而单点的查询则是求前缀和，这样就跟树状数组的基本操作对应起来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> tree[<span class="number">500010</span>], a[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        tree[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; r &gt; <span class="number">0</span>; r -= <span class="built_in">lowbit</span>(r))</span><br><span class="line">        res += tree[r];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">update</span>(a[i] - a[i - <span class="number">1</span>], i, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l, r, k;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">update</span>(k, l, n);</span><br><span class="line">            <span class="built_in">update</span>(-k, r + <span class="number">1</span>, n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">sum</span>(x) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="区间修改，区间查询">区间修改，区间查询</h3><p>既然已经有了单点修改、区间查询和区间修改、单点查询，那么有没有区间修改、区间查询呢？答案是有的。</p><p>首先，既然要区间修改，那我们显然还是要用差分数组，但是要如何做到区间查询呢？假如我们要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的前缀和，那么就需要计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{n=1}^i{sum(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2643em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>的值。如果一个一个的计算太浪费时间，需要寻找一种更为高效的计算方式。</p><p>不难发现，用差分数组求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>前缀和的过程中，第一个元素用到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>次（每一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sum(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>都包含第一个元素），第二个元素用到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>次……以此类推，也就是说上面的公式可以转变为下面这个公式\[ \sum_{n=1}^i{tree[n]\times(i-n+1)} \]稍微变形一下：\[ (i+1)\times \sum_{n=1}^i{tree[n]}-\sum_{n=1}^i{tree[n]\times n} \]假如我们还维护了另一个树状数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>i</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">treei[n]=tree[n]\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mord mathnormal">i</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>那么这个公式就可以变成这样\[ (i+1)\times\sum_{n=i}^i{tree[n]}-\sum_{n=1}^i{treei[n]} \]也就是两个树状数组的前缀和，这样就把原本<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\times\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>的逐项求和转变为了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>的树状数组求前缀和，大大提高了速度。基本代码如下：（找不到例题……）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> tree[N], treei[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= N; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        tree[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> tree[], <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        res += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updatei</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span> </span>&#123;<span class="comment">//更新treei</span></span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= N; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        treei[i] += i * x;  <span class="comment">//其实就是把x变成了x*i……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;   <span class="comment">//求区间和</span></span><br><span class="line">    <span class="type">int</span> ans = (r + <span class="number">1</span>) * <span class="built_in">sum</span>(tree, r) - <span class="built_in">sum</span>(treei, r);</span><br><span class="line">    ans -= (l - <span class="number">1</span> + <span class="number">1</span>) * <span class="built_in">sum</span>(tree, l - <span class="number">1</span>) - <span class="built_in">sum</span>(treei, l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="区间最值">区间最值</h3><p>除了上述的各式各样的区间修改查询以外，树状数组还有一个跟区间有关的功能——维护区间最值。<br>假如我们需要维护区间的最大值，那么正常的想法或许会是每次更新的时候用最大值更新，也就是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        tree[i] = <span class="built_in">max</span>(tree[i], x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样会带来一个问题，如果一个本来是区间最大值的数被替换成了较小的数，那么对应的树状数组显然无法改变。</p><p>如果想要把原数组的变化实时的反映到树状数组中，最为简单暴力的方法就是每次原数组改变的时候都重新建一遍树状数组，也就是把树状数组清零然后重新<em>update</em>一遍，这个方法虽然暴力，但是有效。我们可以在此基础上做一些优化。</p><p>首先，显然我们并不需要每一个区间都清零，只需要把包含修改位置的区间清零并重新<em>update</em><s>废话</s>，同时，由于修改不影响不包含修改位置的区间的正确性，这让我们自然可以想到是否能够将要修改的区间划成几个不包含修改位置的子区间，然后用子区间的值去更新，这样就不需要遍历然后用每一个值去更新。</p><p>那么，总结一下优化的方案：</p><ol><li>只修改包含修改位置的区间；</li><li>用小区间的值去更新大区间的值；</li></ol><p>方案一其实就是树状数组正常的更新，重点在于方案二。如何将其划分为子区间呢？假设现在要修改的位置<em>i</em>为<code>1001 0000</code>，那么第一个要修改的区间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>10000000</mn><mo separator="true">,</mo><mn>10010000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(1000 0000,1001 0000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">10000000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10010000</span><span class="mclose">]</span></span></span></span>。我们模拟一遍清零并重新<em>update</em>的过程，首先先用修改过的值更新一遍：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree[i] = a[i];</span><br></pre></td></tr></table></figure><p>那么接下来就是把区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>10000000</mn><mo separator="true">,</mo><mn>10001111</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(1000 0000,1000 1111]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">10000000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10001111</span><span class="mclose">]</span></span></span></span>拆成小区间，结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1000 1111 --- 1000 1110</span><br><span class="line">1000 1110 --- 1000 1100</span><br><span class="line">1000 1100 --- 1000 1000</span><br><span class="line">1000 1000 --- 1000 0000</span><br></pre></td></tr></table></figure><p>也就是说，需要用的几个值为<code>1000 1111</code>,<code>1000 1110</code>,<code>1000 1100</code>,<code>1000 1000</code>。规律应该很明显了，分别是原数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">-2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">-2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.313em;"></span><span class="minner">⋯</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">-2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，一直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lowbit(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>（不包含<em>lowbit</em>）。</p><p>所以，在维护区间最值的过程中，我们只需要在原本的基础上，用一个数组存储原数组，在每次修改时先修改原数组，再用原数组的值去更新树状数组，最后用一个内循环用小区间的值去更新。由于内循环每次都是乘2，也就是二进制左移一位，复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span></span>，故总体复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((\log{n})^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    a[i] = x;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        tree[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="built_in">lowbit</span>(i); j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            tree[i] = <span class="built_in">max</span>(tree[i], tree[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说完了修改，接下来就是查询了。查询当然也不能像普通的树状数组那样查询，如果要查中间的某一段区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>，也不能方便的直接<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sum(y)-sum(x-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><s>焯</s>。我们依然可以采用上面的思路，把需要查询的区间拆成几个小区间。比如要查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>10010000</mn><mo separator="true">,</mo><mn>10010110</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1001 0000,1001 0110]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">10010000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10010110</span><span class="mclose">]</span></span></span></span>的最值，那么第一个区间就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>10010100</mn><mo separator="true">,</mo><mn>10010110</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(1001 0100,1001 0110]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">10010100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10010110</span><span class="mclose">]</span></span></span></span>。但这样直接拆又会带来一个问题<s>好烦</s>，如果区间改成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>10010101</mn><mo separator="true">,</mo><mn>10010110</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1001 0101,1001 0110]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">10010101</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10010110</span><span class="mclose">]</span></span></span></span>，那么<code>1001 0110</code>所维护的区间就超过了查询的区间，也就无法保证结果的正确性。</p><p>也就是说，在这里我们要稳一手，不能直接拆。如何保证每次拆区间时不越界呢？最简单的方法当然是一次只拆走一个1，但这样就和遍历没有区别了。我们希望，在能拆区间时就拆成区间，只有在迫不得已时才拆走一个1，也就是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y-lowbit(y)&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>的时候就拆走一个1，否则就按正常的区间拆分方式去拆，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= y) &#123; <span class="comment">//为什么是小于等于呢？别忘了树状数组的区间是左开右闭，所以最后要单独用a[x]的值更新一遍。</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a[y]);</span><br><span class="line">        y--;</span><br><span class="line">        <span class="keyword">for</span>(; y - <span class="built_in">lowbit</span>(y) &gt;= x; y -= <span class="built_in">lowbit</span>(y)) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tree[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题<a href="https://www.luogu.com.cn/problem/P1440">P1440</a>（其实这题的标准做法应该是单调队列，但我找不到别的题了……树状数组亲测会t三个点，但不会wa，可以用来检验代码是否有误）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2000010</span>], tree[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        tree[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="built_in">lowbit</span>(i); j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            tree[i] = <span class="built_in">min</span>(tree[i], tree[i - j]);  <span class="comment">// 用子区间数据更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (y &gt;= x) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(a[y], ans);</span><br><span class="line">        y--;</span><br><span class="line">        <span class="keyword">for</span> (; y - <span class="built_in">lowbit</span>(y) &gt;= x; y -= <span class="built_in">lowbit</span>(y))</span><br><span class="line">            ans = <span class="built_in">min</span>(tree[y], ans);</span><br><span class="line">    &#125; <span class="comment">// 把区间x，y划分为小区间</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">update</span>(a[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(<span class="built_in">max</span>(<span class="number">1</span>, i - m), i - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="求逆序对">求逆序对</h3><p>最后一个用法（指我会的，其他更高级的用法还没学……太菜了😭）是统计逆序对数量，相比于上面几种用法而言，统计逆序对不需要对树状数组的原有操作做修改，而是利用树状数组快速求前缀和的特点，对原本的问题进行了巧妙地转换。</p><p>统计逆序对，一种思路是每次在数组后添加新成员时统计前面比它小的数有几个。我们可以用一个数组统计每一个数出现的次数，那么只需要在每一次添加新成员时统计前缀和，就可以算出总共有多少逆序对。同时，由于此方法不关心数据的具体大小而只关心数据之间的大小关系，所以可以采用离散化来减小内存开支。</p><p>例题<a href="https://www.luogu.com.cn/problem/P1908">P1908</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">500010</span>], b[<span class="number">500010</span>], tree[<span class="number">500010</span>], n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; m; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        tree[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res += tree[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; b[mid])</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; b[mid])</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b, b + n);</span><br><span class="line">    m = <span class="built_in">unique</span>(b, b + n) - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">bs</span>(a[i], <span class="number">0</span>, m - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">update</span>(a[i]);</span><br><span class="line">        ans += <span class="built_in">sum</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="UPD：树状数组上二分">UPD：树状数组上二分</h3><p>树状数组既然本质是线段树，那当然就可以在树上进行二分，具体来说，即在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的复杂度下找出第一个前缀和大于某个值的下标，<br>不过，虽然说是二分，但我个人感觉从倍增的角度理解更容易，就类似于树上倍增求lca一样，我们只要从二进制高位到低位一位一位的枚举，小于等于就加，而由于树状数组的特性，我们可以很容易找出一段长度为2的次幂的区间的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要问我为什么函数叫这名，问就是jiangly这么叫的，而我正好取名困难</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(T sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        T cur&#123;&#125;; <span class="comment">// 当前的累计和</span></span><br><span class="line">        <span class="comment">// 从高位向低位枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; std::__lg(n); i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos + i &lt;= n &amp;&amp; sum &gt;= cur + tr[pos + i]) &#123; <span class="comment">// tr[pos + i]维护的就是从pos+1开始的长度为i的区间</span></span><br><span class="line">                cur += tr[pos + i];</span><br><span class="line">                pos |= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos + <span class="number">1</span>; <span class="comment">// pos其实是前缀和不大于sum的最大下标，加1就是大于，可根据实际需求返回对应值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>既然有了二分，那我们就可以干一些更有趣的事，比如用树状数组实现平衡树。<br>当然，说是平衡树，其实就是模仿权值线段树实现了平衡树的功能而已，因此需要先离散化才能使用，功能比较局限。<br><a href="https://www.luogu.com.cn/problem/P3369">洛谷P3369</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">using</span> std::cin, std::cout, std::string;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = std::pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; tr;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> len) : <span class="built_in">tr</span>(len + <span class="number">2</span>), n&#123;len&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">            tr[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T res&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">            res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(T sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        T cur&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; std::__lg(n); i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos + i &lt;= n &amp;&amp; sum &gt;= cur + tr[pos + i]) &#123;</span><br><span class="line">                cur += tr[pos + i];</span><br><span class="line">                pos |= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">// 第k个数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">select</span>(k - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">ask</span>(n);</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    num.<span class="built_in">reserve</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[op, x] : ask) &#123;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op != <span class="number">4</span>)</span><br><span class="line">            num.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">-1e9</span>);</span><br><span class="line">    std::ranges::<span class="built_in">sort</span>(num);</span><br><span class="line">    num.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()), num.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">Fenwick&lt;<span class="type">int</span>&gt; <span class="title">tr</span><span class="params">(num.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [op, x] : ask) &#123;</span><br><span class="line">        x = op != <span class="number">4</span> ? std::ranges::<span class="built_in">lower_bound</span>(num, x) - num.<span class="built_in">begin</span>() : x;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 插入</span></span><br><span class="line">            tr.<span class="built_in">update</span>(x, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 删除</span></span><br><span class="line">            tr.<span class="built_in">update</span>(x, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 排名</span></span><br><span class="line">            std::cout &lt;&lt; tr.<span class="built_in">query</span>(x - <span class="number">1</span>) + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 第k个数</span></span><br><span class="line">            std::cout &lt;&lt; num[tr.<span class="built_in">kth</span>(x)] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 前驱</span></span><br><span class="line">            std::cout &lt;&lt; num[tr.<span class="built_in">kth</span>(tr.<span class="built_in">query</span>(x - <span class="number">1</span>))] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// 后继</span></span><br><span class="line">            std::cout &lt;&lt; num[tr.<span class="built_in">kth</span>(tr.<span class="built_in">query</span>(x) + <span class="number">1</span>)] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结尾">结尾</h2><p>终于肝完了……😵敲了两天，累死我了……</p><hr><p><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/1691338926147.png" alt="img" title="希儿天下第一！！！"></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 入门 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二次逆向题解</title>
      <link href="/posts/57189/"/>
      <url>/posts/57189/</url>
      
        <content type="html"><![CDATA[<p>话不多说，直接开始</p><h2 id="xor">xor</h2><p>下载下来有一个<code>xor</code>的无后缀文件和一个叫<code>_MACOSX</code>的文件夹，里面是一个叫<code>._xor</code>的文件，先查壳<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/xor.png" alt="xor"><br><code>._xor</code>是一个二进制文件，就不放截图了<s>省内存</s><br>用ida打开<code>xor</code>文件<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/main.png" alt="main"><br>用notepad–打开<code>._xor</code>文件<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/xor1.png" alt="xor1"><br>二进制文件有点意义不明，先看主函数，还是熟悉的<code>strncmp</code>函数，可以看到，输入的字符串是<code>_b</code><br>从前面的程序可以看出flag长度为33，输入的字符串每一个字符跟前一个字符异或后才跟<code>global</code>比较，这个字符串的值也很好找，直接点就行<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/str.jpg" alt="str"><br>因为一按截图键窗口就没了，所以只能用手机拍照<br>那么接下来只要找出符合的输入就行了，因为异或的自反性，要还原一个字符只需将其与前一个字符异或即可<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/flag.png" alt="flag"><br>最终flag为<code>QianQiuWanDai_YiTongJiangHu</code><br>不得不说，这个<code>global</code>字符串是真的抽象，一堆转义，眼睛都要看瞎了……<br><s>所以那个二进制文件到底有什么用</s></p><h2 id="helloword">helloword</h2><p><s>是不是少了个l</s><br>下载下来一个apk文件，用jadx打开，找主函数，直接就能看到flag，虽然看不懂java<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/helloword.png" alt="main"></p><h2 id="reverse3">reverse3</h2><p>之前写过了，偷个懒</p><h2 id="不一样的flag">不一样的flag</h2><p>一个exe文件，先查壳，少见的32位应用，无壳。直接打开<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/de.main.png" alt="main"><br>大概翻译一下，一个while循环不断输入一个数字，根据输入改变相应的值，以达到最终结果，所以一步一步的走就行了<br>然后……就不会了</p><hr><p>从题解来看，这题是一个走迷宫题目，迷宫就是<code>v3</code>字符串的内容，即</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*1111</span><br><span class="line">01000</span><br><span class="line">01010</span><br><span class="line">00010</span><br><span class="line">1111#</span><br></pre></td></tr></table></figure><p>数字对应走法，题目中已经给出了提示，走迷宫就行<br>flag为<code>222441144222</code></p><hr><p>写这题是困扰我最久的就是为什么最后判定时用v7字符串数组坐标要-41，因为栈的生长方向是自顶向下，那么先定义的v3字符串地址应该比v7要大，如果以v3为基准引用v7的元素应该是+41，最后在网上找到了解答<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/stack.png" alt="stack"><br>由于栈溢出的保护机制，入栈顺序与定义顺序相反，所以后定义的v7地址反而比v3要大，这样就说得通了。<br>虽然其实可以直接从声明后面的注释看出地址<s>其实看不懂</s>，但知道原因总是好的</p><h2 id="SimpleRev">SimpleRev</h2><p>先查壳，64位无壳，直接打开<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/simplemain.png" alt="main"><br>题目的主函数逐渐开始意义不明……好像找不到什么有用的信息，先看看<code>decty</code>函数和<code>Exit</code>函数<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/decry.png" alt="decry"><br>然后再<code>decry</code>函数里看到了一句Congratulation，不出意外的话到这里就说明找到flag了（<code>Exit</code>函数里啥都没有，应该是没用的）<br>再看回前面，好像没有什么看不懂的地方，直接暴力写出所有变量<br>经过前面一些语句的运行，<code>key</code>字符串为<code>adsfkslcdn</code>，<code>text</code>字符串变为<code>killswodah</code><br>再看后面的输入的部分，输入回车（10）时退出循环开始判定，空格（32）时v2++，然后就是类似解码的过程，根据输入的字符和<code>key</code>字符串构造最后用来比较的字符串，只需一步一步来<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/decryc.png" alt="decry"><br>（因为没看懂有什么特殊含义，就直接暴力了）<br>最终flag为<code>KLDQCOZFDU</code></p><p>然后就错了……</p><hr><p>原因：数据存储方式分为大端序和小端序两种，x86架构（常见）采用小端序，即将低位数据存储在低地址处，powerPC架构（不常见）、网络协议采用大端序，跟小端序相反。如果是存储字符串那么两者没有区别（字符串开头地址较低），但若是存储其他的大于一字节的数据，那么就会不一样。比如存储short（在现在的电脑上一般为4字节，为了方便当成2字节）类型的1<code>00000000 00000001</code>，那么在小端序中存储就是<code>00000000 00000001</code>,而大端序则为<code>00000001 00000000</code>（按地址从高到低算）。而题目中对字符串进行赋值时在后面加了<code>LL</code>（看到了，但不知道有什么区别），即转化为long long型，所以按小端序存储即为<code>77 6F 64 61 68</code>，而字符串是从低到高看，所以转化为字符串应为<code>68 61 64 6F 77</code>，也就是倒过来，正确的<code>key</code>为<code>adsfkndcls</code>，<code>text</code>为<code>killshadow</code>，改了之后程序就能运行出正确的flag，为<code>KLDQCUDFZO</code>。<br>（这鬼设定卡我一晚上，吐了🤮）</p><h2 id="JAVA逆向解密">JAVA逆向解密</h2><p>先查壳（虽然不知道需不需要）<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/java.png" alt="java"><br>用jadx打开<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/javamain.png" alt="main"><br>根本看不懂java……</p><p>在同为计算机系的兄弟的帮助下，大概知道了意思，就是输入字符串，改变一下跟<code>key</code>比较，直接编程就行<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/javaflag.png" alt="flag"><br>最终flag为<code>This_is_the_flag_!</code></p><h2 id="GXYCTF2019-luck-guy">[GXYCTF2019]luck_guy</h2><p>查壳，64位无壳，直接打开<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/luckymain.png" alt="main"><br>主函数没有有用信息，但可以找到一个<code>get_flag</code>函数，可以猜测这个函数是关键<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/getflag.png" alt="get_flag"><br>其中，<code>rand</code>函数用于生成伪随机数，<code>f1</code>可以直接找到，为<code>GXY&#123;do_not_</code>,f2在<code>case4</code>中被赋值，在<code>case5</code>中被改变，而flag<code>s</code>由<code>f1 f2</code>拼接而成，只要敲个代码就行（同样由于小端序存储，字符串要倒过来）<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/lucflag.png" alt="flag" title="其实是照着网上敲的，python早忘的差不多了"><br>最终flag为<code>do_not_hate_me</code></p><hr><h2 id="结语">结语</h2><p>肝不动了😵<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/kelala.jpg" alt="kelala"></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107/"/>
      <url>/posts/16107/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一次逆向题解</title>
      <link href="/posts/47809/"/>
      <url>/posts/47809/</url>
      
        <content type="html"><![CDATA[<p>应组长要求<s>完成任务</s>将第一次写逆向题的过程记录一下<br>顺便让以后的自己能够回过头来看看当初青涩的模样（感叹一下时光飞逝来装大佬）</p><hr><h2 id="正文">正文</h2><h3 id="一、easyre">一、easyre</h3><p>首先，照葫芦画瓢，下载文件并解压，可以看到一个exe文件，直接拖入ida，可以看到以下界面<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20232952.png" alt="图片"><br>然后继续照葫芦画瓢，找到主函数<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20234237.png" alt="图片"><br>然后就找到了flag……<br>虽然不知道发生了什么，但反正找到了，下一题。</p><h3 id="二、reverse1">二、reverse1</h3><p>省略重复步骤，找到main函数<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/reserve1main.png" alt="picture"><br>嗯……好像啥都没有，但可以看到一个main_0函数，点进去<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/reserve_main_0.png" alt="picture"><br>然后翻译一下函数的内容，大概就是有一个<code>str2</code>字符串，程序会比较输入的字符串和str2字符串，如果一样就输出<code>this is the right flag</code>，那么目标应该就是要找到这个<code>str2</code>字符串的内容了<br>那么要如何查看呢，这个时候就要求助我们万能的百度了，于是知道了按x可以查看变量的交叉引用，然后就可以看到<code>str2</code>的值为<code>hello_world</code><br><s>主要是因为真的找不到str2到底在哪里被赋的值</s><br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/str2.png" alt="str2"><br>当然不要忘了前面有一个for循环对str2的值进行了改变，将asc值为111的字母改为了48。百度可知111为o，48为0。所以flag应为<code>hell0_w0rld</code></p><h3 id="三、reverse2">三、reverse2</h3><p>继续第三题，这次的文件比较奇特，没有后缀名，但ida好像可以直接打开，就不管了<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/reverse2.main.png" alt="picture"><br>好像跟上一题差不多，但这次的flag变成了指针，按x查看交叉引用会发现没有出现值<br>……然后，经过半小时的摸索，终于在data区看到了flag<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/reverse2.flag.png" alt="picture"><br>因为我也不太清楚是怎么搞出来的……所以没有截图，大概就是根据百度，右键字符串然后点击array可以改变字符串长度（我没记错的话在没改变之前是没有显示字符的，不然我也不会找这么久了），然后随便调个长度，就显示出来了。<br>同样，由于主函数对flag的值做了改变，这并不是最终的flag，最终的flag为<code>hack1ng_fo1_fun</code></p><h3 id="四、新年快乐">四、新年快乐</h3><p>这一题的文件是32位的，先换成32位的ida来打开，然后……整整318行代码，果断跳过。</p><h3 id="四、内涵的软件">四、内涵的软件</h3><p>这题看半天没看出怎么写，然后被迫百度题解，然后发现答案就摆在面前……<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/neihanflag.png" alt="picture"><br>主要是不知道这个DBAPP就指的flag，白找好久……</p><h3 id="五、reverse3">五、reverse3</h3><p><s>还是reverse系列的题友好，不需要查壳之类的听不懂的操作。</s><br>找到主函数，还是熟悉的字符串比较<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/reverse3main.png" alt="picture"></p><hr><p>苦思半小时无果，百度题解，然后就看到了base64加密……<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/base64.png" alt="base64"><br>鬼知道这个抽象的函数是base64加密啊！！！</p><hr><h2 id="结尾">结尾</h2><p>除了最简单的3题以外，基本全靠题解……基础的reverse知识还是知道的太少了，看到抽象点的函数基本只能跳过，还是先去找点reverse基础教程再写题吧……<br><img src="https://remi-riya-img.oss-cn-beijing.aliyuncs.com/zi.gif" alt="zi"></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
